[
    {
        "name": "Morphir.Elm.Frontend",
        "comment": " The Elm frontend turns Elm source code into Morphir IR.\n\n\n# Entry points\n\n@docs packageDefinitionFromSource, mapDeclarationsToType\n\n\n# Utilities\n\n@docs defaultDependencies\n\n@docs Options, ContentLocation, ContentRange, Error, Errors, PackageInfo, SourceFile, SourceLocation, mapSource\n@docs mapValueToFile\n@docs parseRawValue\n\n",
        "unions": [
            {
                "name": "Error",
                "comment": " ",
                "args": [],
                "cases": [
                    [
                        "ParseError",
                        [
                            "String.String",
                            "List.List Parser.DeadEnd"
                        ]
                    ],
                    [
                        "CyclicModules",
                        [
                            "Morphir.Graph.Graph () (List.List String.String)"
                        ]
                    ],
                    [
                        "ResolveError",
                        [
                            "Morphir.Elm.Frontend.SourceLocation",
                            "Morphir.Elm.Frontend.Resolve.Error"
                        ]
                    ],
                    [
                        "EmptyApply",
                        [
                            "Morphir.Elm.Frontend.SourceLocation"
                        ]
                    ],
                    [
                        "NotSupported",
                        [
                            "Morphir.Elm.Frontend.SourceLocation",
                            "String.String"
                        ]
                    ],
                    [
                        "DuplicateNameInPattern",
                        [
                            "Morphir.IR.Name.Name",
                            "Morphir.Elm.Frontend.SourceLocation",
                            "Morphir.Elm.Frontend.SourceLocation"
                        ]
                    ],
                    [
                        "VariableShadowing",
                        [
                            "Morphir.IR.Name.Name",
                            "Morphir.Elm.Frontend.SourceLocation",
                            "Morphir.Elm.Frontend.SourceLocation"
                        ]
                    ],
                    [
                        "MissingTypeSignature",
                        [
                            "Morphir.Elm.Frontend.SourceLocation"
                        ]
                    ],
                    [
                        "RecordPatternNotSupported",
                        [
                            "Morphir.Elm.Frontend.SourceLocation"
                        ]
                    ],
                    [
                        "TypeInferenceError",
                        [
                            "Morphir.Elm.Frontend.SourceLocation",
                            "Morphir.Type.Infer.TypeError"
                        ]
                    ]
                ]
            }
        ],
        "aliases": [
            {
                "name": "ContentLocation",
                "comment": " ",
                "args": [],
                "type": "{ row : Basics.Int, column : Basics.Int }"
            },
            {
                "name": "ContentRange",
                "comment": " ",
                "args": [],
                "type": "{ start : Morphir.Elm.Frontend.ContentLocation, end : Morphir.Elm.Frontend.ContentLocation }"
            },
            {
                "name": "Errors",
                "comment": " ",
                "args": [],
                "type": "List.List Morphir.Elm.Frontend.Error"
            },
            {
                "name": "Options",
                "comment": " Options that modify the behavior of the frontend:\n\n    - `typesOnly` - only include type information in the IR, no values\n\n",
                "args": [],
                "type": "{ typesOnly : Basics.Bool }"
            },
            {
                "name": "PackageInfo",
                "comment": " ",
                "args": [],
                "type": "{ name : Morphir.IR.Path.Path, exposedModules : Maybe.Maybe (Set.Set Morphir.IR.Path.Path) }"
            },
            {
                "name": "SourceFile",
                "comment": " ",
                "args": [],
                "type": "{ path : String.String, content : String.String }"
            },
            {
                "name": "SourceLocation",
                "comment": " ",
                "args": [],
                "type": "{ source : Morphir.Elm.Frontend.SourceFile, range : Morphir.Elm.Frontend.ContentRange }"
            }
        ],
        "values": [
            {
                "name": "defaultDependencies",
                "comment": " Dependencies that are added by default without explicit reference.\n",
                "type": "Dict.Dict Morphir.IR.Path.Path (Morphir.IR.Package.Specification ())"
            },
            {
                "name": "mapDeclarationsToType",
                "comment": " Function that turns `elm-syntax` declarations to Morphir IR types.\n",
                "type": "Morphir.Elm.Frontend.SourceFile -> Elm.Syntax.Exposing.Exposing -> List.List Elm.Syntax.Declaration.Declaration -> Result.Result Morphir.Elm.Frontend.Errors (List.List ( Morphir.IR.Name.Name, Morphir.IR.AccessControlled.AccessControlled (Morphir.IR.Documented.Documented (Morphir.IR.Type.Definition Morphir.Elm.Frontend.SourceLocation)) ))"
            },
            {
                "name": "mapSource",
                "comment": " ",
                "type": "Morphir.Elm.Frontend.Options -> Morphir.Elm.Frontend.PackageInfo -> Dict.Dict Morphir.IR.Path.Path (Morphir.IR.Package.Specification ()) -> List.List Morphir.Elm.Frontend.SourceFile -> Result.Result (List.List Morphir.Compiler.Error) (Morphir.IR.Package.Definition Morphir.Elm.Frontend.SourceLocation Morphir.Elm.Frontend.SourceLocation)"
            },
            {
                "name": "mapValueToFile",
                "comment": " ",
                "type": "Morphir.IR.IR -> Morphir.IR.Type.Type () -> String.String -> Result.Result String.String Morphir.IR.IR"
            },
            {
                "name": "packageDefinitionFromSource",
                "comment": " Function that takes some package info and a list of sources and returns Morphir IR or errors.\n",
                "type": "Morphir.Elm.Frontend.Options -> Morphir.Elm.Frontend.PackageInfo -> Dict.Dict Morphir.IR.Path.Path (Morphir.IR.Package.Specification ()) -> List.List Morphir.Elm.Frontend.SourceFile -> Result.Result Morphir.Elm.Frontend.Errors (Morphir.IR.Package.Definition Morphir.Elm.Frontend.SourceLocation Morphir.Elm.Frontend.SourceLocation)"
            },
            {
                "name": "parseRawValue",
                "comment": " Parses an expression written in the Elm syntax into a RawValue.\n",
                "type": "Morphir.IR.IR -> String.String -> Result.Result String.String Morphir.IR.Value.RawValue"
            }
        ],
        "binops": []
    },
    {
        "name": "Morphir.Elm.Frontend.Codec",
        "comment": " Codecs for types in the `Morphir.Elm.Frontend` module.\n\n\n# Options\n\n@docs decodeOptions\n\n\n# PackageInfo\n\n@docs decodePackageInfo\n\n\n# DeadEnd\n\n@docs encodeDeadEnd\n\n\n# SourceFile\n\n@docs encodeSourceFile\n\n\n# Error\n\n@docs encodeError\n\n\n# ContentLocation\n\n@docs encodeContentLocation\n\n\n# ContentRange\n\n@docs encodeContentRange\n\n\n# SourceLocation\n\n@docs encodeSourceLocation\n\n",
        "unions": [],
        "aliases": [],
        "values": [
            {
                "name": "decodeOptions",
                "comment": " Decode Options.\n",
                "type": "Json.Decode.Decoder Morphir.Elm.Frontend.Options"
            },
            {
                "name": "decodePackageInfo",
                "comment": " Encode PackageInfo.\n",
                "type": "Json.Decode.Decoder Morphir.Elm.Frontend.PackageInfo"
            },
            {
                "name": "encodeContentLocation",
                "comment": " Encode ContentLocation.\n",
                "type": "Morphir.Elm.Frontend.ContentLocation -> Json.Encode.Value"
            },
            {
                "name": "encodeContentRange",
                "comment": " Encode ContentRange.\n",
                "type": "Morphir.Elm.Frontend.ContentRange -> Json.Encode.Value"
            },
            {
                "name": "encodeDeadEnd",
                "comment": " Encode DeadEnd.\n",
                "type": "Parser.DeadEnd -> Json.Encode.Value"
            },
            {
                "name": "encodeError",
                "comment": " Encode Error.\n",
                "type": "Morphir.Elm.Frontend.Error -> Json.Encode.Value"
            },
            {
                "name": "encodeSourceFile",
                "comment": " Encode SourceFile.\n",
                "type": "Morphir.Elm.Frontend.SourceFile -> Json.Encode.Value"
            },
            {
                "name": "encodeSourceLocation",
                "comment": " Encode SourceLocation.\n",
                "type": "Morphir.Elm.Frontend.SourceLocation -> Json.Encode.Value"
            }
        ],
        "binops": []
    },
    {
        "name": "Morphir.Elm.IncrementalResolve",
        "comment": " This module contains functionality to resolve names in the Elm code into Morphir fully-qualified names. The process\nis relatively complex due to the many ways names can be imported in an Elm module. Here, we split up the overall process\ninto three main steps following the structure of an Elm module:\n\n@docs resolveModuleName, resolveImports, resolveLocalName, ResolvedImports, VisibleNames\n\n\n# Errors\n\n@docs Error\n\n",
        "unions": [
            {
                "name": "Error",
                "comment": " Type that represents all the possible errors during the name resolution process. Here are the possible errors:\n\n  - **NoMorphirPackageFoundForElmModule**\n      - Reported during the process of mapping the Elm module name into a pair of Morphir package and module name.\n      - Arguments: Elm module name\n  - **ModuleNotImported**\n      - Reported when the module that a name refers to is not mentioned in the imports\n      - Arguments: Elm module name\n  - **ModuleOrAliasNotImported**\n      - Reported when a single name module prefix is not found in the imports. This could either refer to an alias or a\n        top-level module but we don't know which one since it's not imported.\n      - Arguments: Elm module name or alias\n  - **ModuleDoesNotExposeLocalName**\n      - Reported when we know which module a name is supposed to be in but that module does not expose or doesn't contain\n        that name.\n      - Arguments: package name, module name, local name, kind of name (type, constructor or value)\n  - **ModulesDoNotExposeLocalName**\n      - Reported when it's not clear which module should contain the local name but neither contains or exposes it.\n      - Arguments: the alias that was used in the Elm code, matching module names, local name, kind of name (type, constructor or value)\n  - **MultipleModulesExposeLocalName**\n      - Reported when multiple modules expose the local name and it's unclear which one the user meant.\n      - Arguments: matching module names, local name, kind of name (type, constructor or value)\n  - **LocalNameNotImported**\n      - Reported when a local name is not found in the imports.\n      - Arguments: local name, kind of name (type, constructor or value)\n  - **ImportedModuleNotFound**\n      - Reported when a module is imported but not available in the Repo.\n      - Arguments: package and module name\n  - **ImportedLocalNameNotFound**\n      - Reported when a local name is imported but not found in the Repo.\n      - Arguments: package and module name, local name, kind of name (type, constructor or value)\n  - **ImportingConstructorsOfNonCustomType**\n      - Reported when an import is trying to expose constructors of a type but the type name does not refer to a custom type\n      - Arguments: package and module name, local name\n\n",
                "args": [],
                "cases": [
                    [
                        "NoMorphirPackageFoundForElmModule",
                        [
                            "List.List String.String"
                        ]
                    ],
                    [
                        "ModuleNotImported",
                        [
                            "List.List String.String"
                        ]
                    ],
                    [
                        "ModuleOrAliasNotImported",
                        [
                            "String.String"
                        ]
                    ],
                    [
                        "ModuleDoesNotExposeLocalName",
                        [
                            "Morphir.IR.Package.PackageName",
                            "Morphir.IR.Module.ModuleName",
                            "Morphir.IR.Name.Name",
                            "Morphir.IR.KindOfName.KindOfName"
                        ]
                    ],
                    [
                        "ModulesDoNotExposeLocalName",
                        [
                            "String.String",
                            "List.List Morphir.Elm.IncrementalResolve.QualifiedModuleName",
                            "Morphir.IR.Name.Name",
                            "Morphir.IR.KindOfName.KindOfName"
                        ]
                    ],
                    [
                        "MultipleModulesExposeLocalName",
                        [
                            "List.List Morphir.Elm.IncrementalResolve.QualifiedModuleName",
                            "Morphir.IR.Name.Name",
                            "Morphir.IR.KindOfName.KindOfName"
                        ]
                    ],
                    [
                        "LocalNameNotImported",
                        [
                            "Morphir.IR.Name.Name",
                            "Morphir.IR.KindOfName.KindOfName"
                        ]
                    ],
                    [
                        "ImportedModuleNotFound",
                        [
                            "Morphir.Elm.IncrementalResolve.QualifiedModuleName"
                        ]
                    ],
                    [
                        "ImportedLocalNameNotFound",
                        [
                            "Morphir.Elm.IncrementalResolve.QualifiedModuleName",
                            "Morphir.IR.Name.Name",
                            "Morphir.IR.KindOfName.KindOfName"
                        ]
                    ],
                    [
                        "ImportingConstructorsOfNonCustomType",
                        [
                            "Morphir.Elm.IncrementalResolve.QualifiedModuleName",
                            "Morphir.IR.Name.Name"
                        ]
                    ]
                ]
            }
        ],
        "aliases": [
            {
                "name": "ResolvedImports",
                "comment": " Internal data structure for efficient lookup of names based on imports.\n",
                "args": [],
                "type": "{ visibleNamesByModuleName : Dict.Dict Morphir.Elm.IncrementalResolve.QualifiedModuleName Morphir.Elm.IncrementalResolve.VisibleNames, moduleNamesByAliasOrSingleModuleName : Dict.Dict String.String (Set.Set Morphir.Elm.IncrementalResolve.QualifiedModuleName), moduleNamesByLocalTypeName : Dict.Dict Morphir.IR.Name.Name (Set.Set Morphir.Elm.IncrementalResolve.QualifiedModuleName), moduleNamesByLocalValueName : Dict.Dict Morphir.IR.Name.Name (Set.Set Morphir.Elm.IncrementalResolve.QualifiedModuleName), moduleNamesByLocalConstructorName : Dict.Dict Morphir.IR.Name.Name (Set.Set Morphir.Elm.IncrementalResolve.QualifiedModuleName) }"
            },
            {
                "name": "VisibleNames",
                "comment": " Represents the names that a module exposes or makes internally available.\n",
                "args": [],
                "type": "{ types : Set.Set Morphir.IR.Name.Name, constructors : Set.Set Morphir.IR.Name.Name, values : Set.Set Morphir.IR.Name.Name }"
            }
        ],
        "values": [
            {
                "name": "resolveImports",
                "comment": " Resolve the imports into an internal data structure that makes it easier to resolve names within the module. This is\ndone once per module.\n",
                "type": "Morphir.IR.Repo.Repo -> List.List Elm.Syntax.Import.Import -> Result.Result Morphir.Elm.IncrementalResolve.Error Morphir.Elm.IncrementalResolve.ResolvedImports"
            },
            {
                "name": "resolveLocalName",
                "comment": " Resolve each individual name using the data structure mentioned above. This is done for each type, constructor and\nvalue name in the module.\n",
                "type": "Morphir.IR.Repo.Repo -> Morphir.IR.Module.ModuleName -> Morphir.Elm.IncrementalResolve.VisibleNames -> Morphir.Elm.IncrementalResolve.ResolvedImports -> List.List String.String -> Morphir.IR.KindOfName.KindOfName -> String.String -> Result.Result Morphir.Elm.IncrementalResolve.Error Morphir.IR.FQName.FQName"
            },
            {
                "name": "resolveModuleName",
                "comment": " Finds out the Morphir package and module name from an Elm module name and a Repo.\n",
                "type": "Morphir.IR.Repo.Repo -> List.List String.String -> Result.Result Morphir.Elm.IncrementalResolve.Error Morphir.Elm.IncrementalResolve.QualifiedModuleName"
            }
        ],
        "binops": []
    },
    {
        "name": "Morphir.File.FileMap",
        "comment": " A FileMap represents a set of text files as a dictionary of file names to file content.\n\n@docs FileMap\n\n",
        "unions": [],
        "aliases": [
            {
                "name": "FileMap",
                "comment": " Type that represents a file path to content mapping.\n",
                "args": [],
                "type": "Dict.Dict ( List.List String.String, String.String ) String.String"
            }
        ],
        "values": [],
        "binops": []
    },
    {
        "name": "Morphir.File.FileMap.Codec",
        "comment": " Codecs for types in the `Morphir.File.FileMap` module.\n\n\n# FileMap\n\n@docs encodeFileMap\n\n",
        "unions": [],
        "aliases": [],
        "values": [
            {
                "name": "encodeFileMap",
                "comment": " Encode FileMap.\n",
                "type": "Morphir.File.FileMap.FileMap -> Json.Encode.Value"
            }
        ],
        "binops": []
    },
    {
        "name": "Morphir.File.SourceCode",
        "comment": " Utilities related to generating source code.\n\n@docs Doc, concat, dot, dotSep, empty, indent, indentLines, newLine, parens, semi, space\n\n",
        "unions": [],
        "aliases": [
            {
                "name": "Doc",
                "comment": " Type that represents a part or the whole document.\n",
                "args": [],
                "type": "String.String"
            }
        ],
        "values": [
            {
                "name": "concat",
                "comment": " Concatenates a list of documents.\n",
                "type": "List.List Morphir.File.SourceCode.Doc -> Morphir.File.SourceCode.Doc"
            },
            {
                "name": "dot",
                "comment": " Single dot character.\n",
                "type": "Morphir.File.SourceCode.Doc"
            },
            {
                "name": "dotSep",
                "comment": " Concatenates a list of documents separating them with dots.\n",
                "type": "List.List Morphir.File.SourceCode.Doc -> Morphir.File.SourceCode.Doc"
            },
            {
                "name": "empty",
                "comment": " Empty document.\n",
                "type": "Morphir.File.SourceCode.Doc"
            },
            {
                "name": "indent",
                "comment": " Indent the specified string. If the string contains multiple lines they will all be indented.\n",
                "type": "Basics.Int -> Morphir.File.SourceCode.Doc -> Morphir.File.SourceCode.Doc"
            },
            {
                "name": "indentLines",
                "comment": " Indent the specified list of string. If the string contains multiple lines they will all be indented.\n",
                "type": "Basics.Int -> List.List Morphir.File.SourceCode.Doc -> Morphir.File.SourceCode.Doc"
            },
            {
                "name": "newLine",
                "comment": " Single new line.\n",
                "type": "Morphir.File.SourceCode.Doc"
            },
            {
                "name": "parens",
                "comment": " Wraps the document into parenthesis.\n",
                "type": "Morphir.File.SourceCode.Doc -> Morphir.File.SourceCode.Doc"
            },
            {
                "name": "semi",
                "comment": " Single semi-colon.\n",
                "type": "Morphir.File.SourceCode.Doc"
            },
            {
                "name": "space",
                "comment": " Single space character.\n",
                "type": "Morphir.File.SourceCode.Doc"
            }
        ],
        "binops": []
    },
    {
        "name": "Morphir.Graph.Grapher",
        "comment": " The Grapher module analyses a distribution to build a graph for dependency and lineage tracking purposes.\nThe goal is to understand data flow and to automate contribution to the types of products that are commonly used in\nenterprises. The result of processing is a [Graph](#Graph), which is a collection of [Nodes](#Node) and [Edges](#Edge).\n\n\n# Types\n\n@docs Node, Verb, Edge, GraphEntry, Graph\n\n\n# Processing\n\n@docs mapDistribution, mapPackageDefinition, mapModuleTypes, mapModuleValues, mapTypeDefinition, mapValueDefinition\n\n\n# Utilities\n\n@docs graphEntryToComparable, nodeType, verbToString, nodeFQN, asEnum, edgeFromTuple, edgeToTuple, fqnToString\n\n",
        "unions": [
            {
                "name": "GraphEntry",
                "comment": " Defines the possible graph entries of [Node](#Node) and [Edge](#Edge).\n",
                "args": [],
                "cases": [
                    [
                        "NodeEntry",
                        [
                            "Morphir.Graph.Grapher.Node"
                        ]
                    ],
                    [
                        "EdgeEntry",
                        [
                            "Morphir.Graph.Grapher.Edge"
                        ]
                    ]
                ]
            },
            {
                "name": "Node",
                "comment": " Node defines a node in the graph. We capture specific node types for this purpose.\nThe types of constructs that we're interested in tracking are:\n\n  - **Record** - Represents collection of fields. Corresponds to [Morphir.IR.Type.Record](/src/Morphir/IR/Type/Record)\n  - **Field** - Represents a field within a Record.\n  - **Type** - Represents a Type or Type Alias, which we want to track aliases through their hierarchies.\n  - **Function** - Represents a Function.\n  - **Enum** - Represents a restricted set of single name values.\n  - **Function** - Represents a type that defines a strong unit of measure.\n  - **Unknown** - Questionable practice, but it's useful to identify relationships we might want to track in the future.\n\n",
                "args": [],
                "cases": [
                    [
                        "Record",
                        [
                            "Morphir.IR.FQName.FQName"
                        ]
                    ],
                    [
                        "Field",
                        [
                            "Morphir.IR.FQName.FQName",
                            "Morphir.IR.Name.Name"
                        ]
                    ],
                    [
                        "Type",
                        [
                            "Morphir.IR.FQName.FQName"
                        ]
                    ],
                    [
                        "Function",
                        [
                            "Morphir.IR.FQName.FQName"
                        ]
                    ],
                    [
                        "Enum",
                        [
                            "Morphir.IR.FQName.FQName"
                        ]
                    ],
                    [
                        "UnitOfMeasure",
                        [
                            "Morphir.IR.FQName.FQName"
                        ]
                    ],
                    [
                        "Unknown",
                        [
                            "String.String"
                        ]
                    ]
                ]
            },
            {
                "name": "Verb",
                "comment": " Verb defines the possible relationships that we're interested in tracking. These are used to define the relationships\nin the edges of our graph.\n\n  - **IsA** - Denotes an implementation of a [Type](#Node) by fields, function parameters, and the such.\n  - **Aliases** - Denotes a type alias, for which we want to track the full hierarchy.\n  - **Contains** - Denotes [Fields](#Field) contained in a [Record](#Node)\n  - **Uses** - Denotes use of a type by a [Function](#Node).\n  - **Calls** - Denotes a [Function](#Node) call within another Function.\n  - **Produces** - Denotes the output of a [Function](#Node).\n  - **Parameterizes** - Denotes type variable usage.\n  - **Unions** - Denotes the [Types](#Node) utilized in a union type.\n\n",
                "args": [],
                "cases": [
                    [
                        "IsA",
                        []
                    ],
                    [
                        "Aliases",
                        []
                    ],
                    [
                        "Contains",
                        []
                    ],
                    [
                        "Uses",
                        []
                    ],
                    [
                        "Calls",
                        []
                    ],
                    [
                        "Produces",
                        []
                    ],
                    [
                        "Parameterizes",
                        []
                    ],
                    [
                        "Measures",
                        []
                    ],
                    [
                        "Unions",
                        []
                    ],
                    [
                        "Enumerates",
                        []
                    ]
                ]
            }
        ],
        "aliases": [
            {
                "name": "Edge",
                "comment": " Defines an edge in the graph as a triple of the subject node, the relationship, and the object node.\n",
                "args": [],
                "type": "{ subject : Morphir.Graph.Grapher.Node, verb : Morphir.Graph.Grapher.Verb, object : Morphir.Graph.Grapher.Node }"
            },
            {
                "name": "Graph",
                "comment": " Defines a graph as a collection of nodes and edges.\n",
                "args": [],
                "type": "List.List Morphir.Graph.Grapher.GraphEntry"
            }
        ],
        "values": [
            {
                "name": "asEnum",
                "comment": " ",
                "type": "Morphir.IR.Type.Definition ta -> List.List Morphir.IR.Name.Name"
            },
            {
                "name": "edgeFromTuple",
                "comment": " Converte Edge record to tuple\n",
                "type": "( Morphir.Graph.Grapher.Node, Morphir.Graph.Grapher.Verb, Morphir.Graph.Grapher.Node ) -> Morphir.Graph.Grapher.Edge"
            },
            {
                "name": "edgeToTuple",
                "comment": " Converte Edge record to tuple\n",
                "type": "Morphir.Graph.Grapher.Edge -> ( Morphir.Graph.Grapher.Node, Morphir.Graph.Grapher.Verb, Morphir.Graph.Grapher.Node )"
            },
            {
                "name": "fqnToString",
                "comment": " Utility for dealing with comparable.\n",
                "type": "Morphir.IR.FQName.FQName -> String.String"
            },
            {
                "name": "graphEntryToComparable",
                "comment": " Utility for dealing with comparable.\n",
                "type": "Morphir.Graph.Grapher.GraphEntry -> String.String"
            },
            {
                "name": "mapDistribution",
                "comment": " Process this distribution into a Graph of its packages.\n",
                "type": "Morphir.IR.Distribution.Distribution -> Morphir.Graph.Grapher.Graph"
            },
            {
                "name": "mapModuleTypes",
                "comment": " Process this module to collect the types used and produced by it.\n",
                "type": "Morphir.IR.Package.PackageName -> Morphir.IR.Module.ModuleName -> Morphir.IR.Module.Definition ta va -> Morphir.Graph.Grapher.Graph"
            },
            {
                "name": "mapModuleValues",
                "comment": " Process this module to collect the functions and relationships to types.\n",
                "type": "Morphir.IR.Package.PackageName -> Morphir.IR.Module.ModuleName -> Morphir.IR.Module.Definition ta va -> Dict.Dict String.String Morphir.Graph.Grapher.Node -> Morphir.Graph.Grapher.Graph"
            },
            {
                "name": "mapPackageDefinition",
                "comment": " Process this package into a Graph of its modules. We take two passes to the IR. The first collects all of the\ntypes and the second processes the functions and their relationships to those types.\n",
                "type": "Morphir.IR.Package.PackageName -> Morphir.IR.Package.Definition ta va -> Morphir.Graph.Grapher.Graph"
            },
            {
                "name": "mapTypeDefinition",
                "comment": " Process a type since there are a lot of variations.\n",
                "type": "Morphir.IR.Package.PackageName -> Morphir.IR.Module.ModuleName -> Morphir.IR.Name.Name -> Morphir.IR.Type.Definition ta -> Morphir.Graph.Grapher.Graph"
            },
            {
                "name": "mapValueDefinition",
                "comment": " Process [Functions](#Type) specifically and ignore the rest.\n",
                "type": "Morphir.IR.Package.PackageName -> Morphir.IR.Module.ModuleName -> Morphir.IR.Name.Name -> Morphir.IR.Value.Definition ta va -> Dict.Dict String.String Morphir.Graph.Grapher.Node -> Morphir.Graph.Grapher.Graph"
            },
            {
                "name": "nodeFQN",
                "comment": " Utility to extract the [Fully Qualified Name](/src/Morphir/IR/FQName) from a [Node](#Node). This is required\nbecause a Field contains both an FQN and field name.\n",
                "type": "Morphir.Graph.Grapher.Node -> Morphir.IR.FQName.FQName"
            },
            {
                "name": "nodeType",
                "comment": " Utility to extract the [Node](#Node) type as a String.\n",
                "type": "Morphir.Graph.Grapher.Node -> String.String"
            },
            {
                "name": "verbToString",
                "comment": " Utility for dealing with comparable.\n",
                "type": "Morphir.Graph.Grapher.Verb -> String.String"
            }
        ],
        "binops": []
    },
    {
        "name": "Morphir.IR",
        "comment": " This module contains data structures and functions to make working with the IR easier and more efficient.\n\n@docs IR\n\n\n# Conversions\n\n@docs fromPackageSpecifications, fromDistribution\n\n\n# Lookups\n\n@docs typeSpecifications\n@docs lookupTypeSpecification, lookupTypeConstructor, lookupValueSpecification, lookupValueDefinition\n\n\n# Utilities\n\n@docs empty, resolveAliases, resolveType, resolveRecordConstructors\n\n",
        "unions": [],
        "aliases": [
            {
                "name": "IR",
                "comment": " Data structure to store types and values efficiently.\n",
                "args": [],
                "type": "{ valueSpecifications : Dict.Dict Morphir.IR.FQName.FQName (Morphir.IR.Value.Specification ()), valueDefinitions : Dict.Dict Morphir.IR.FQName.FQName (Morphir.IR.Value.Definition () (Morphir.IR.Type.Type ())), typeSpecifications : Dict.Dict Morphir.IR.FQName.FQName (Morphir.IR.Type.Specification ()), typeConstructors : Dict.Dict Morphir.IR.FQName.FQName ( Morphir.IR.FQName.FQName, List.List Morphir.IR.Name.Name, List.List ( Morphir.IR.Name.Name, Morphir.IR.Type.Type () ) ) }"
            }
        ],
        "values": [
            {
                "name": "empty",
                "comment": " Creates an empty IR with no types or values.\n",
                "type": "Morphir.IR.IR"
            },
            {
                "name": "fromDistribution",
                "comment": " Turn a `Distribution` into an `IR`. The `Distribution` data type is optimized for transfer while the `IR` data type\nis optimized for efficient in-memory processing.\n",
                "type": "Morphir.IR.Distribution.Distribution -> Morphir.IR.IR"
            },
            {
                "name": "fromPackageSpecifications",
                "comment": " Turn a dictionary of package specifications into an `IR`.\n",
                "type": "Dict.Dict Morphir.IR.Package.PackageName (Morphir.IR.Package.Specification ()) -> Morphir.IR.IR"
            },
            {
                "name": "lookupTypeConstructor",
                "comment": " Look up a type constructor by fully-qualified name. Dependencies will be included in the search. The function\nreturns a tuple with the following elements:\n\n  - The fully-qualified name of the type that this constructor belongs to.\n  - The type arguments of the type.\n  - The list of arguments (as name-type pairs) for this constructor.\n\n",
                "type": "Morphir.IR.FQName.FQName -> Morphir.IR.IR -> Maybe.Maybe ( Morphir.IR.FQName.FQName, List.List Morphir.IR.Name.Name, List.List ( Morphir.IR.Name.Name, Morphir.IR.Type.Type () ) )"
            },
            {
                "name": "lookupTypeSpecification",
                "comment": " Look up a type specification by fully-qualified name. Dependencies will be included in the search.\n",
                "type": "Morphir.IR.FQName.FQName -> Morphir.IR.IR -> Maybe.Maybe (Morphir.IR.Type.Specification ())"
            },
            {
                "name": "lookupValueDefinition",
                "comment": " Look up a value definition by fully-qualified name. Dependencies will not be included in the search.\n",
                "type": "Morphir.IR.FQName.FQName -> Morphir.IR.IR -> Maybe.Maybe (Morphir.IR.Value.Definition () (Morphir.IR.Type.Type ()))"
            },
            {
                "name": "lookupValueSpecification",
                "comment": " Look up a value specification by fully-qualified name. Dependencies will be included in the search.\n",
                "type": "Morphir.IR.FQName.FQName -> Morphir.IR.IR -> Maybe.Maybe (Morphir.IR.Value.Specification ())"
            },
            {
                "name": "resolveAliases",
                "comment": " Follow direct aliases until the leaf type is found.\n",
                "type": "Morphir.IR.FQName.FQName -> Morphir.IR.IR -> Morphir.IR.FQName.FQName"
            },
            {
                "name": "resolveRecordConstructors",
                "comment": " Replace record constructors with the corresponding record value.\n",
                "type": "Morphir.IR.Value.Value ta va -> Morphir.IR.IR -> Morphir.IR.Value.Value ta va"
            },
            {
                "name": "resolveType",
                "comment": " Fully resolve all type aliases in the type.\n",
                "type": "Morphir.IR.Type.Type () -> Morphir.IR.IR -> Morphir.IR.Type.Type ()"
            },
            {
                "name": "typeSpecifications",
                "comment": " Get all type specifications.\n",
                "type": "Morphir.IR.IR -> Dict.Dict Morphir.IR.FQName.FQName (Morphir.IR.Type.Specification ())"
            }
        ],
        "binops": []
    },
    {
        "name": "Morphir.IR.AccessControlled",
        "comment": " Module to manage access to a node in the IR. This is only used to declare access levels\nnot to enforce them. Enforcement can be done through the helper functions\n[withPublicAccess](#withPublicAccess) and [withPrivateAccess](#withPrivateAccess) but it's\nup to the consumer of the API to call the right function.\n\n@docs AccessControlled, Access\n\n\n# Creation\n\n@docs public, private\n\n\n# Query\n\n@docs withPublicAccess, withPrivateAccess, withAccess\n\n\n# Transform\n\n@docs map\n\n",
        "unions": [
            {
                "name": "Access",
                "comment": " Public or private access.\n",
                "args": [],
                "cases": [
                    [
                        "Public",
                        []
                    ],
                    [
                        "Private",
                        []
                    ]
                ]
            }
        ],
        "aliases": [
            {
                "name": "AccessControlled",
                "comment": " Type that represents different access levels.\n",
                "args": [
                    "a"
                ],
                "type": "{ access : Morphir.IR.AccessControlled.Access, value : a }"
            }
        ],
        "values": [
            {
                "name": "map",
                "comment": " Apply a function to the access controlled value but keep the access unchanged.\n",
                "type": "(a -> b) -> Morphir.IR.AccessControlled.AccessControlled a -> Morphir.IR.AccessControlled.AccessControlled b"
            },
            {
                "name": "private",
                "comment": " Mark a node as private access. Only actors with private access level can see.\n",
                "type": "a -> Morphir.IR.AccessControlled.AccessControlled a"
            },
            {
                "name": "public",
                "comment": " Mark a node as public access. Actors with both public and private access are allowed to see.\n",
                "type": "a -> Morphir.IR.AccessControlled.AccessControlled a"
            },
            {
                "name": "withAccess",
                "comment": " Get the value with public or private access level. Will return `Nothing` if the value is private and accessed using\npublic access.\n\n    withAccess Public (public 13) -- Just 13\n\n    withAccess Public (private 13) -- Nothing\n\n    withAccess Private (public 13) -- 13\n\n    withAccess Private (private 13) -- 13\n\n",
                "type": "Morphir.IR.AccessControlled.Access -> Morphir.IR.AccessControlled.AccessControlled a -> Maybe.Maybe a"
            },
            {
                "name": "withPrivateAccess",
                "comment": " Get the value with private access level. Will always return the value.\n\n    withPrivateAccess (public 13) -- 13\n\n    withPrivateAccess (private 13) -- 13\n\n",
                "type": "Morphir.IR.AccessControlled.AccessControlled a -> a"
            },
            {
                "name": "withPublicAccess",
                "comment": " Get the value with public access level. Will return `Nothing` if the value is private.\n\n    withPublicAccess (public 13) -- Just 13\n\n    withPublicAccess (private 13) -- Nothing\n\n",
                "type": "Morphir.IR.AccessControlled.AccessControlled a -> Maybe.Maybe a"
            }
        ],
        "binops": []
    },
    {
        "name": "Morphir.IR.Distribution",
        "comment": " A distribution is a complete package of Morphir types and functions with all their dependencies.\n`morphir-elm make` produces a JSON that represents a `Distribution`. We are planning to define different types of\ndistributions in the future but currently the only one is `Library`. A library contains the following pieces of\ninformation:\n\n  - The name of the library. This is the globally unique identifier of the package like the package name in NPM or the\n    Group and Artifact ID in Maven.\n  - All the library dependencies as a dictionary of package name and package specification. The package specification\n    only contains type signatures, no implementations.\n  - The package definition which contains all the module definitions included in the library. The package definition\n    contains implementations as well, even ones that are not exposed.\n\n@docs Distribution\n\n\n# Lookups\n\n@docs lookupModuleSpecification, lookupTypeSpecification, lookupValueSpecification, lookupBaseTypeName, lookupValueDefinition\n@docs lookupPackageSpecification, lookupPackageName\n\n\n# Updates\n\n@docs insertDependency\n\n",
        "unions": [
            {
                "name": "Distribution",
                "comment": " Type that represents a package distribution. Currently the only distribution type we provide is a `Library`.\n",
                "args": [],
                "cases": [
                    [
                        "Library",
                        [
                            "Morphir.IR.Package.PackageName",
                            "Dict.Dict Morphir.IR.Package.PackageName (Morphir.IR.Package.Specification ())",
                            "Morphir.IR.Package.Definition () (Morphir.IR.Type.Type ())"
                        ]
                    ]
                ]
            }
        ],
        "aliases": [],
        "values": [
            {
                "name": "insertDependency",
                "comment": " Add a package specification as a dependency of this library.\n",
                "type": "Morphir.IR.Package.PackageName -> Morphir.IR.Package.Specification () -> Morphir.IR.Distribution.Distribution -> Morphir.IR.Distribution.Distribution"
            },
            {
                "name": "lookupBaseTypeName",
                "comment": " Look up the base type name following aliases by package, module and local name in a distribution.\n",
                "type": "Morphir.IR.FQName.FQName -> Morphir.IR.Distribution.Distribution -> Maybe.Maybe Morphir.IR.FQName.FQName"
            },
            {
                "name": "lookupModuleSpecification",
                "comment": " Look up a module specification by package and module path in a distribution.\n",
                "type": "Morphir.IR.Package.PackageName -> Morphir.IR.Module.ModuleName -> Morphir.IR.Distribution.Distribution -> Maybe.Maybe (Morphir.IR.Module.Specification ())"
            },
            {
                "name": "lookupPackageName",
                "comment": " Get the package name of a distribution.\n",
                "type": "Morphir.IR.Distribution.Distribution -> Morphir.IR.Package.PackageName"
            },
            {
                "name": "lookupPackageSpecification",
                "comment": " Get the package specification of a distribution.\n",
                "type": "Morphir.IR.Distribution.Distribution -> Morphir.IR.Package.Specification ()"
            },
            {
                "name": "lookupTypeSpecification",
                "comment": " Look up a type specification by package, module and local name in a distribution.\n",
                "type": "Morphir.IR.Package.PackageName -> Morphir.IR.Module.ModuleName -> Morphir.IR.Name.Name -> Morphir.IR.Distribution.Distribution -> Maybe.Maybe (Morphir.IR.Type.Specification ())"
            },
            {
                "name": "lookupValueDefinition",
                "comment": " Look up a value definition by qualified name in a distribution. The value will only be searched in the current\npackage.\n",
                "type": "Morphir.IR.QName.QName -> Morphir.IR.Distribution.Distribution -> Maybe.Maybe (Morphir.IR.Value.Definition () (Morphir.IR.Type.Type ()))"
            },
            {
                "name": "lookupValueSpecification",
                "comment": " Look up a value specification by package, module and local name in a distribution.\n",
                "type": "Morphir.IR.Package.PackageName -> Morphir.IR.Module.ModuleName -> Morphir.IR.Name.Name -> Morphir.IR.Distribution.Distribution -> Maybe.Maybe (Morphir.IR.Value.Specification ())"
            }
        ],
        "binops": []
    },
    {
        "name": "Morphir.IR.Distribution.Codec",
        "comment": " Codecs for types in the `Morphir.IR.Distribution` module.\n\n\n# Distribution\n\n@docs encodeVersionedDistribution, decodeVersionedDistribution, encodeDistribution, decodeDistribution\n\n",
        "unions": [],
        "aliases": [],
        "values": [
            {
                "name": "decodeDistribution",
                "comment": " Decode Distribution.\n",
                "type": "Json.Decode.Decoder Morphir.IR.Distribution.Distribution"
            },
            {
                "name": "decodeVersionedDistribution",
                "comment": " Decode distribution including a version number.\n",
                "type": "Json.Decode.Decoder Morphir.IR.Distribution.Distribution"
            },
            {
                "name": "encodeDistribution",
                "comment": " Encode Distribution.\n",
                "type": "Morphir.IR.Distribution.Distribution -> Json.Encode.Value"
            },
            {
                "name": "encodeVersionedDistribution",
                "comment": " Encode distribution including a version number.\n",
                "type": "Morphir.IR.Distribution.Distribution -> Json.Encode.Value"
            }
        ],
        "binops": []
    },
    {
        "name": "Morphir.IR.Documented",
        "comment": "\n\n@docs Documented, map\n\n",
        "unions": [],
        "aliases": [
            {
                "name": "Documented",
                "comment": " Type that represents a documented value.\n",
                "args": [
                    "a"
                ],
                "type": "{ doc : String.String, value : a }"
            }
        ],
        "values": [
            {
                "name": "map",
                "comment": " ",
                "type": "(a -> b) -> Morphir.IR.Documented.Documented a -> Morphir.IR.Documented.Documented b"
            }
        ],
        "binops": []
    },
    {
        "name": "Morphir.IR.FQName",
        "comment": " Module to work with fully-qualified names. A qualified name is a combination of a package path, a module path and a local name.\n\n@docs FQName, fQName, fromQName, getPackagePath, getModulePath, getLocalName, fqn, toString, fromString\n\n",
        "unions": [],
        "aliases": [
            {
                "name": "FQName",
                "comment": " Type that represents a fully-qualified name.\nThe parameters are PackagePath ModulePath Name\n",
                "args": [],
                "type": "( Morphir.IR.Path.Path, Morphir.IR.Path.Path, Morphir.IR.Name.Name )"
            }
        ],
        "values": [
            {
                "name": "fQName",
                "comment": " Create a fully-qualified name.\n",
                "type": "Morphir.IR.Path.Path -> Morphir.IR.Path.Path -> Morphir.IR.Name.Name -> Morphir.IR.FQName.FQName"
            },
            {
                "name": "fqn",
                "comment": " Convenience function to create a fully-qualified name from 3 strings.\n",
                "type": "String.String -> String.String -> String.String -> Morphir.IR.FQName.FQName"
            },
            {
                "name": "fromQName",
                "comment": " Create a fully-qualified from a qualified name.\n",
                "type": "Morphir.IR.Path.Path -> Morphir.IR.QName.QName -> Morphir.IR.FQName.FQName"
            },
            {
                "name": "fromString",
                "comment": " Parse a string into a FQName using splitter as the separator between package, module and local names.\n",
                "type": "String.String -> String.String -> Morphir.IR.FQName.FQName"
            },
            {
                "name": "getLocalName",
                "comment": " Get the local name part of a fully-qualified name.\n",
                "type": "Morphir.IR.FQName.FQName -> Morphir.IR.Name.Name"
            },
            {
                "name": "getModulePath",
                "comment": " Get the module path part of a fully-qualified name.\n",
                "type": "Morphir.IR.FQName.FQName -> Morphir.IR.Path.Path"
            },
            {
                "name": "getPackagePath",
                "comment": " Get the package path part of a fully-qualified name.\n",
                "type": "Morphir.IR.FQName.FQName -> Morphir.IR.Path.Path"
            },
            {
                "name": "toString",
                "comment": " Convert a fully-qualified name to a string\n",
                "type": "Morphir.IR.FQName.FQName -> String.String"
            }
        ],
        "binops": []
    },
    {
        "name": "Morphir.IR.Literal",
        "comment": " Literals represent fixed values in the IR. We support the same set of basic types as Elm which almost matches JSON's supported values:\n\n  - Bool\n  - Char\n  - String\n  - Int\n  - Float\n\n@docs Literal, boolLiteral, charLiteral, stringLiteral, intLiteral, floatLiteral\n\n",
        "unions": [
            {
                "name": "Literal",
                "comment": " Type that represents a literal value.\n",
                "args": [],
                "cases": [
                    [
                        "BoolLiteral",
                        [
                            "Basics.Bool"
                        ]
                    ],
                    [
                        "CharLiteral",
                        [
                            "Char.Char"
                        ]
                    ],
                    [
                        "StringLiteral",
                        [
                            "String.String"
                        ]
                    ],
                    [
                        "WholeNumberLiteral",
                        [
                            "Basics.Int"
                        ]
                    ],
                    [
                        "FloatLiteral",
                        [
                            "Basics.Float"
                        ]
                    ],
                    [
                        "DecimalLiteral",
                        [
                            "Morphir.SDK.Decimal.Decimal"
                        ]
                    ]
                ]
            }
        ],
        "aliases": [],
        "values": [
            {
                "name": "boolLiteral",
                "comment": " Represents a boolean value. Only possible values are: `True`, `False`\n",
                "type": "Basics.Bool -> Morphir.IR.Literal.Literal"
            },
            {
                "name": "charLiteral",
                "comment": " Represents a character value. Some possible values: `'a'`, `'Z'`, `'3'`\n",
                "type": "Char.Char -> Morphir.IR.Literal.Literal"
            },
            {
                "name": "floatLiteral",
                "comment": " Represents a floating-point number. Some possible values: `1.25`, `-13.4`\n",
                "type": "Basics.Float -> Morphir.IR.Literal.Literal"
            },
            {
                "name": "intLiteral",
                "comment": " Represents an integer value. Some possible values: `0`, `-1`, `9832479`\n",
                "type": "Basics.Int -> Morphir.IR.Literal.Literal"
            },
            {
                "name": "stringLiteral",
                "comment": " Represents a string value. Some possible values: `\"\"`, `\"foo\"`, `\"Bar baz: 123\"`\n",
                "type": "String.String -> Morphir.IR.Literal.Literal"
            }
        ],
        "binops": []
    },
    {
        "name": "Morphir.IR.Module",
        "comment": " Modules are used to group types and values together to make them easier to find. A module serves the same purpose as\na package in Java or namespaces in other languages. A module is identified by a module name within the package. Within a\nmodule each type and value is identified using a local name.\n\n@docs ModuleName, QualifiedModuleName\n\n\n# Specification vs Definition\n\nModules are available at two different levels of detail. A module specification only contains types that are exposed\npublicly and type signatures for values that are exposed publicly. A module definition contains all the details\nincluding implementation and private types and values.\n\n@docs Specification, emptySpecification\n@docs Definition, emptyDefinition\n@docs definitionToSpecification, definitionToSpecificationWithPrivate\n\n\n# Lookups\n\n@docs lookupTypeSpecification, lookupValueSpecification, lookupValueDefinition\n\n\n# Manage attributes\n\n@docs eraseSpecificationAttributes, eraseDefinitionAttributes\n@docs mapDefinitionAttributes, mapSpecificationAttributes\n@docs collectTypeReferences, collectValueReferences, collectReferences, dependsOnModules\n\n",
        "unions": [],
        "aliases": [
            {
                "name": "Definition",
                "comment": " Type that represents a module definition. A module definition contains all the details\nincluding implementation and private types and values.\n\nA module contains types and values which is represented by two field in this type:\n\n  - types: a dictionary of local name to access controlled, documented type specification.\n  - values: a dictionary of local name to access controlled value specification.\n\nType variables ta and va refer to type annotation and value annotation\n",
                "args": [
                    "ta",
                    "va"
                ],
                "type": "{ types : Dict.Dict Morphir.IR.Name.Name (Morphir.IR.AccessControlled.AccessControlled (Morphir.IR.Documented.Documented (Morphir.IR.Type.Definition ta))), values : Dict.Dict Morphir.IR.Name.Name (Morphir.IR.AccessControlled.AccessControlled (Morphir.IR.Documented.Documented (Morphir.IR.Value.Definition ta va))) }"
            },
            {
                "name": "ModuleName",
                "comment": " A module name is a unique identifier for a module within a package. It is represented by a path, which is a list of\nnames.\n",
                "args": [],
                "type": "Morphir.IR.Path.Path"
            },
            {
                "name": "QualifiedModuleName",
                "comment": " A qualified module name is a globally unique identifier for a module. It is represented by a tuple of the package\nand the module name.\n",
                "args": [],
                "type": "( Morphir.IR.Path.Path, Morphir.IR.Path.Path )"
            },
            {
                "name": "Specification",
                "comment": " Type that represents a module specification. A module specification only contains types that are exposed\npublicly and type signatures for values that are exposed publicly.\n\nA module contains types and values which is represented by two field in this type:\n\n  - types: a dictionary of local name to documented type specification.\n  - values: a dictionary of local name to value specification.\n\n",
                "args": [
                    "ta"
                ],
                "type": "{ types : Dict.Dict Morphir.IR.Name.Name (Morphir.IR.Documented.Documented (Morphir.IR.Type.Specification ta)), values : Dict.Dict Morphir.IR.Name.Name (Morphir.IR.Documented.Documented (Morphir.IR.Value.Specification ta)) }"
            }
        ],
        "values": [
            {
                "name": "collectReferences",
                "comment": " Collect all type and value references from the module.\n",
                "type": "Morphir.IR.Module.Definition ta va -> Set.Set Morphir.IR.FQName.FQName"
            },
            {
                "name": "collectTypeReferences",
                "comment": " Collect all type references from the module.\n",
                "type": "Morphir.IR.Module.Definition ta va -> Set.Set Morphir.IR.FQName.FQName"
            },
            {
                "name": "collectValueReferences",
                "comment": " Collect all value references from the module.\n",
                "type": "Morphir.IR.Module.Definition ta va -> Set.Set Morphir.IR.FQName.FQName"
            },
            {
                "name": "definitionToSpecification",
                "comment": " Turn a module definition into a module specification. Only publicly exposed types and values will be included in the\nresult.\n",
                "type": "Morphir.IR.Module.Definition ta va -> Morphir.IR.Module.Specification ta"
            },
            {
                "name": "definitionToSpecificationWithPrivate",
                "comment": " Turn a module definition into a module specification. Non-exposed types and values will also be included in the\nresult.\n",
                "type": "Morphir.IR.Module.Definition ta va -> Morphir.IR.Module.Specification ta"
            },
            {
                "name": "dependsOnModules",
                "comment": " Find all the modules that this module depends on.\n",
                "type": "Morphir.IR.Module.Definition ta va -> Set.Set Morphir.IR.Module.QualifiedModuleName"
            },
            {
                "name": "emptyDefinition",
                "comment": " Get an empty module definition with no types or values.\n",
                "type": "Morphir.IR.Module.Definition ta va"
            },
            {
                "name": "emptySpecification",
                "comment": " Get an empty module specification with no types or values.\n",
                "type": "Morphir.IR.Module.Specification ta"
            },
            {
                "name": "eraseDefinitionAttributes",
                "comment": " Remove all type attributes from a module definition.\n",
                "type": "Morphir.IR.Module.Definition ta va -> Morphir.IR.Module.Definition () ()"
            },
            {
                "name": "eraseSpecificationAttributes",
                "comment": " Remove all type attributes from a module specification.\n",
                "type": "Morphir.IR.Module.Specification ta -> Morphir.IR.Module.Specification ()"
            },
            {
                "name": "lookupTypeSpecification",
                "comment": " Look up a type specification by its name in a module specification.\n",
                "type": "Morphir.IR.Name.Name -> Morphir.IR.Module.Specification ta -> Maybe.Maybe (Morphir.IR.Type.Specification ta)"
            },
            {
                "name": "lookupValueDefinition",
                "comment": " Look up a value definition by its name in a module specification.\n",
                "type": "Morphir.IR.Name.Name -> Morphir.IR.Module.Definition ta va -> Maybe.Maybe (Morphir.IR.Value.Definition ta va)"
            },
            {
                "name": "lookupValueSpecification",
                "comment": " Look up a value specification by its name in a module specification.\n",
                "type": "Morphir.IR.Name.Name -> Morphir.IR.Module.Specification ta -> Maybe.Maybe (Morphir.IR.Value.Specification ta)"
            },
            {
                "name": "mapDefinitionAttributes",
                "comment": " ",
                "type": "(ta -> tb) -> (va -> vb) -> Morphir.IR.Module.Definition ta va -> Morphir.IR.Module.Definition tb vb"
            },
            {
                "name": "mapSpecificationAttributes",
                "comment": " ",
                "type": "(ta -> tb) -> Morphir.IR.Module.Specification ta -> Morphir.IR.Module.Specification tb"
            }
        ],
        "binops": []
    },
    {
        "name": "Morphir.IR.Name",
        "comment": " `Name` is an abstraction of human-readable identifiers made up of words. This abstraction\nallows us to use the same identifiers across various naming conventions used by the different\nfrontend and backend languages Morphir integrates with.\n\n    name = fromList [ \"value\", \"in\", \"u\", \"s\", \"d\" ]\n\n    toTitleCase name --> \"ValueInUSD\"\n    toCamelCase name --> \"valueInUSD\"\n    toSnakeCase name --> \"value_in_USD\"\n\n\n## Abbreviations\n\nWe frequently use abbreviations in a business context to be more concise.\nFrom a naming perspective abbreviations are challanging because they are not real words and\nbehave slightly differently. In this module we treat abbreviations as a list of single-letter\nwords. This approach fits nicely into camel and title case naming conventions but when using\nsnake-case the direct translation would look unnatural:\n\n    toSnakeCase name -- \"value_in_u_s_d\" ?\n\nTo resolve this and help creating human-readable strings we added functionality to turn\nabbreviations into upper-case words. We treat any series of single letter words as an\nabbreviation:\n\n    toSnakeCase name --> \"value_in_USD\"\n\n@docs Name, fromList, toList\n\n\n# String conversion\n\n@docs fromString, toTitleCase, toCamelCase, toSnakeCase, toHumanWords\n\n",
        "unions": [],
        "aliases": [
            {
                "name": "Name",
                "comment": " Type that represents a name that is made up of words.\n",
                "args": [],
                "type": "List.List String.String"
            }
        ],
        "values": [
            {
                "name": "fromList",
                "comment": " Convert a list of strings into a name.\n",
                "type": "List.List String.String -> Morphir.IR.Name.Name"
            },
            {
                "name": "fromString",
                "comment": " Translate a string into a name by splitting it into words. The algorithm is designed\nto work with most well-known naming conventions or mix of them. The general rule is that\nconsecutive letters and numbers are treated as words, upper-case letters and non-alphanumeric\ncharacters start a new word.\n\n    fromString \"fooBar_baz 123\"\n    --> Name.fromList [ \"foo\", \"bar\", \"baz\", \"123\" ]\n\n    fromString \"valueInUSD\"\n    --> Name.fromList [ \"value\", \"in\", \"u\", \"s\", \"d\" ]\n\n    fromString \"ValueInUSD\"\n    --> Name.fromList [ \"value\", \"in\", \"u\", \"s\", \"d\" ]\n\n    fromString \"value_in_USD\"\n    --> Name.fromList [ \"value\", \"in\", \"u\", \"s\", \"d\" ]\n\n    fromString \"_-%\"\n    --> Name.fromList []\n\n",
                "type": "String.String -> Morphir.IR.Name.Name"
            },
            {
                "name": "toCamelCase",
                "comment": " Turns a name into a camel-case string.\n\n    toCamelCase (fromList [ \"foo\", \"bar\", \"baz\", \"123\" ])\n    --> \"fooBarBaz123\"\n\n    toCamelCase (fromList [ \"value\", \"in\", \"u\", \"s\", \"d\" ])\n    --> \"valueInUSD\"\n\n",
                "type": "Morphir.IR.Name.Name -> String.String"
            },
            {
                "name": "toHumanWords",
                "comment": " Turns a name into a list of human-readable strings. The only difference\ncompared to [`toList`](#toList) is how it handles abbreviations. They will\nbe turned into a single upper-case word instead of separate single-character\nwords.\n\n    toHumanWords (fromList [ \"value\", \"in\", \"u\", \"s\", \"d\" ])\n    --> [ \"value\", \"in\", \"USD\" ]\n\n",
                "type": "Morphir.IR.Name.Name -> List.List String.String"
            },
            {
                "name": "toList",
                "comment": " Convert a name to a list of strings.\n",
                "type": "Morphir.IR.Name.Name -> List.List String.String"
            },
            {
                "name": "toSnakeCase",
                "comment": " Turns a name into a snake-case string.\n\n    toSnakeCase (fromList [ \"foo\", \"bar\", \"baz\", \"123\" ])\n    --> \"foo_bar_baz_123\"\n\n    toSnakeCase (fromList [ \"value\", \"in\", \"u\", \"s\", \"d\" ])\n    --> \"value_in_USD\"\n\n",
                "type": "Morphir.IR.Name.Name -> String.String"
            },
            {
                "name": "toTitleCase",
                "comment": " Turns a name into a title-case string.\n\n    toTitleCase (fromList [ \"foo\", \"bar\", \"baz\", \"123\" ])\n    --> \"FooBarBaz123\"\n\n    toTitleCase (fromList [ \"value\", \"in\", \"u\", \"s\", \"d\" ])\n    --> \"ValueInUSD\"\n\n",
                "type": "Morphir.IR.Name.Name -> String.String"
            }
        ],
        "binops": []
    },
    {
        "name": "Morphir.IR.Package",
        "comment": " A package is collection of types and values that are versioned together. If this sounds abstract just think of any\nof the popular package managers you are familiar with: NPM, NuGet, Maven, pip or Cabal. What they consider a package is\nwhat this represents. A package contains modules which further group types and values.\n\n\n# Specification vs Definition\n\nPackages are available at two different levels of detail. A package specification only contains types that are exposed\npublicly and type signatures for values that are exposed publicly. A package definition contains all the details\nincluding implementation and private types and values.\n\n@docs Specification, emptySpecification\n\n@docs Definition, emptyDefinition\n\n\n# Lookups\n\n@docs lookupModuleSpecification, lookupModuleDefinition, lookupTypeSpecification, lookupValueSpecification, lookupValueDefinition\n\n\n# Other utilities\n\n@docs PackageName, definitionToSpecification, definitionToSpecificationWithPrivate, eraseDefinitionAttributes, eraseSpecificationAttributes\n@docs mapDefinitionAttributes, mapSpecificationAttributes, selectModules, modulesOrderedByDependency\n\n",
        "unions": [],
        "aliases": [
            {
                "name": "Definition",
                "comment": " Type that represents a package definition. A package definition contains all the details including implementation\nand private types and values. The modules field is a dictionary keyed by module name that contains access controlled\nmodule definitions. The `AccessControlled` adds access classifiers to each module to differentiate public and private\nmodules.\n",
                "args": [
                    "ta",
                    "va"
                ],
                "type": "{ modules : Dict.Dict Morphir.IR.Module.ModuleName (Morphir.IR.AccessControlled.AccessControlled (Morphir.IR.Module.Definition ta va)) }"
            },
            {
                "name": "PackageName",
                "comment": " A package name is a globally unique identifier for a package. It is represented by a path, which is a list of names.\n",
                "args": [],
                "type": "Morphir.IR.Path.Path"
            },
            {
                "name": "Specification",
                "comment": " Type that represents a package specification. A package specification only contains types that are exposed publicly\nand type signatures for values that are exposed publicly.\n",
                "args": [
                    "ta"
                ],
                "type": "{ modules : Dict.Dict Morphir.IR.Module.ModuleName (Morphir.IR.Module.Specification ta) }"
            }
        ],
        "values": [
            {
                "name": "definitionToSpecification",
                "comment": " Turn a package definition into a package specification. Only publicly exposed modules will be included in the\nresult.\n",
                "type": "Morphir.IR.Package.Definition ta va -> Morphir.IR.Package.Specification ta"
            },
            {
                "name": "definitionToSpecificationWithPrivate",
                "comment": " Turn a package definition into a package specification. Non-exposed modules will also be included in the\nresult.\n",
                "type": "Morphir.IR.Package.Definition ta va -> Morphir.IR.Package.Specification ta"
            },
            {
                "name": "emptyDefinition",
                "comment": " Get an empty package definition with no modules.\n",
                "type": "Morphir.IR.Package.Definition ta va"
            },
            {
                "name": "emptySpecification",
                "comment": " Get an empty package specification with no modules.\n",
                "type": "Morphir.IR.Package.Specification ta"
            },
            {
                "name": "eraseDefinitionAttributes",
                "comment": " Remove all type and value attributes from a package definition.\n",
                "type": "Morphir.IR.Package.Definition ta va -> Morphir.IR.Package.Definition () ()"
            },
            {
                "name": "eraseSpecificationAttributes",
                "comment": " Remove all type attributes from a package specification.\n",
                "type": "Morphir.IR.Package.Specification ta -> Morphir.IR.Package.Specification ()"
            },
            {
                "name": "lookupModuleDefinition",
                "comment": " Look up a module definition by its path in a package specification.\n",
                "type": "Morphir.IR.Path.Path -> Morphir.IR.Package.Definition ta va -> Maybe.Maybe (Morphir.IR.Module.Definition ta va)"
            },
            {
                "name": "lookupModuleSpecification",
                "comment": " Look up a module specification by its path in a package specification.\n",
                "type": "Morphir.IR.Path.Path -> Morphir.IR.Package.Specification ta -> Maybe.Maybe (Morphir.IR.Module.Specification ta)"
            },
            {
                "name": "lookupTypeSpecification",
                "comment": " Look up a type specification by its module path and name in a package specification.\n",
                "type": "Morphir.IR.Path.Path -> Morphir.IR.Name.Name -> Morphir.IR.Package.Specification ta -> Maybe.Maybe (Morphir.IR.Type.Specification ta)"
            },
            {
                "name": "lookupValueDefinition",
                "comment": " Look up a value definition by its module path and name in a package specification.\n",
                "type": "Morphir.IR.Path.Path -> Morphir.IR.Name.Name -> Morphir.IR.Package.Definition ta va -> Maybe.Maybe (Morphir.IR.Value.Definition ta va)"
            },
            {
                "name": "lookupValueSpecification",
                "comment": " Look up a value specification by its module path and name in a package specification.\n",
                "type": "Morphir.IR.Path.Path -> Morphir.IR.Name.Name -> Morphir.IR.Package.Specification ta -> Maybe.Maybe (Morphir.IR.Value.Specification ta)"
            },
            {
                "name": "mapDefinitionAttributes",
                "comment": " Map all type and value attributes of a package definition.\n",
                "type": "(ta -> tb) -> (va -> vb) -> Morphir.IR.Package.Definition ta va -> Morphir.IR.Package.Definition tb vb"
            },
            {
                "name": "mapSpecificationAttributes",
                "comment": " Map all type attributes of a package specification.\n",
                "type": "(ta -> tb) -> Morphir.IR.Package.Specification ta -> Morphir.IR.Package.Specification tb"
            },
            {
                "name": "modulesOrderedByDependency",
                "comment": " Get the list of modules within this package ordered by dependency. If module B depends on A than module B is\nguaranteed to be after A in the list.\n",
                "type": "Morphir.IR.Package.PackageName -> Morphir.IR.Package.Definition () (Morphir.IR.Type.Type ()) -> Result.Result (Morphir.Dependency.DAG.CycleDetected Morphir.IR.Module.ModuleName) (List.List ( Morphir.IR.Module.ModuleName, Morphir.IR.AccessControlled.AccessControlled (Morphir.IR.Module.Definition () (Morphir.IR.Type.Type ())) ))"
            },
            {
                "name": "selectModules",
                "comment": " Filter down the modules in this distribution to the specified modules and their transitive dependencies.\n",
                "type": "Set.Set Morphir.IR.Module.ModuleName -> Morphir.IR.Package.PackageName -> Morphir.IR.Package.Definition ta va -> Morphir.IR.Package.Definition ta va"
            }
        ],
        "binops": []
    },
    {
        "name": "Morphir.IR.Package.Codec",
        "comment": " Codecs for types in the `Morphir.IR.Package` module.\n\n\n# Specification\n\n@docs encodeSpecification, decodeSpecification\n\n\n# Definition\n\n@docs encodeDefinition, decodeDefinition\n\n",
        "unions": [],
        "aliases": [],
        "values": [
            {
                "name": "decodeDefinition",
                "comment": " Decode Definition.\n",
                "type": "Json.Decode.Decoder ta -> Json.Decode.Decoder va -> Json.Decode.Decoder (Morphir.IR.Package.Definition ta va)"
            },
            {
                "name": "decodeSpecification",
                "comment": " Decode Specification.\n",
                "type": "Json.Decode.Decoder ta -> Json.Decode.Decoder (Morphir.IR.Package.Specification ta)"
            },
            {
                "name": "encodeDefinition",
                "comment": " Encode Definition.\n",
                "type": "(ta -> Json.Encode.Value) -> (va -> Json.Encode.Value) -> Morphir.IR.Package.Definition ta va -> Json.Encode.Value"
            },
            {
                "name": "encodeSpecification",
                "comment": " Encode Specification.\n",
                "type": "(ta -> Json.Encode.Value) -> Morphir.IR.Package.Specification ta -> Json.Encode.Value"
            }
        ],
        "binops": []
    },
    {
        "name": "Morphir.IR.Path",
        "comment": " `Path` is a list of names that represents a path in the tree. It's used at various\nplaces in the IR to identify types and values.\n\n@docs Path, fromList, toList\n\n\n# String conversion\n\n@docs fromString, toString\n\n\n# Utilities\n\n@docs isPrefixOf\n\n",
        "unions": [],
        "aliases": [
            {
                "name": "Path",
                "comment": " Type that represents a path as a list of names.\n",
                "args": [],
                "type": "List.List Morphir.IR.Name.Name"
            }
        ],
        "values": [
            {
                "name": "fromList",
                "comment": " Converts a list of names to a path.\n",
                "type": "List.List Morphir.IR.Name.Name -> Morphir.IR.Path.Path"
            },
            {
                "name": "fromString",
                "comment": " Translates a string into a path by splitting it into names along special characters.\nThe algorithm will treat any non-word charaters that are not spaces as a path separator.\n\n    fromString \"fooBar.Baz\"\n    --> Path.fromList\n    -->     [ Name.fromList [ \"foo\", \"bar\" ]\n    -->     , Name.fromList [ \"baz\" ]\n    -->     ]\n\n    fromString \"foo bar/baz\"\n    --> Path.fromList\n    -->     [ Name.fromList [ \"foo\", \"bar\" ]\n    -->     , Name.fromList [ \"baz\" ]\n    -->     ]\n\n",
                "type": "String.String -> Morphir.IR.Path.Path"
            },
            {
                "name": "isPrefixOf",
                "comment": " Checks if a path is a prefix of another.\n\n    isPrefixOf [ [ \"foo\" ], [ \"bar\" ] ] [ [ \"foo\" ] ] == True\n\n    isPrefixOf [ [ \"foo\" ] ] [ [ \"foo\" ], [ \"bar\" ] ] == False\n\n    isPrefixOf [ [ \"foo\" ], [ \"bar\" ] ] [ [ \"foo\" ], [ \"bar\" ] ] == True\n\n",
                "type": "Morphir.IR.Path.Path -> Morphir.IR.Path.Path -> Basics.Bool"
            },
            {
                "name": "toList",
                "comment": " Converts a path to a list of names.\n",
                "type": "Morphir.IR.Path.Path -> List.List Morphir.IR.Name.Name"
            },
            {
                "name": "toString",
                "comment": " Turn a path into a string using the specified naming convention and separator.\n\n    path =\n        Path.fromList\n            [ Name.fromList [ \"foo\", \"bar\" ]\n            , Name.fromList [ \"baz\" ]\n            ]\n\n    toString Name.toTitleCase \".\" path\n    --> \"FooBar.Baz\"\n\n    toString Name.toSnakeCase \"/\" path\n    --> \"foo_bar/baz\"\n\n",
                "type": "(Morphir.IR.Name.Name -> String.String) -> String.String -> Morphir.IR.Path.Path -> String.String"
            }
        ],
        "binops": []
    },
    {
        "name": "Morphir.IR.QName",
        "comment": " Module to work with qualified names. A qualified name is a combination of a module path and a local name.\n\n@docs QName, toTuple, getModulePath, getLocalName\n\n\n# Creation\n\n@docs fromName, fromTuple\n\n\n# String conversion\n\n@docs fromString, toString\n\n",
        "unions": [
            {
                "name": "QName",
                "comment": " Type that represents a qualified name.\n",
                "args": [],
                "cases": [
                    [
                        "QName",
                        [
                            "Morphir.IR.Path.Path",
                            "Morphir.IR.Name.Name"
                        ]
                    ]
                ]
            }
        ],
        "aliases": [],
        "values": [
            {
                "name": "fromName",
                "comment": " Creates a qualified name.\n",
                "type": "Morphir.IR.Path.Path -> Morphir.IR.Name.Name -> Morphir.IR.QName.QName"
            },
            {
                "name": "fromString",
                "comment": " Parse a string into a QName using `:` as the separator between module and local names.\n",
                "type": "String.String -> Maybe.Maybe Morphir.IR.QName.QName"
            },
            {
                "name": "fromTuple",
                "comment": " Turn a tuple into a qualified name.\n",
                "type": "( Morphir.IR.Path.Path, Morphir.IR.Name.Name ) -> Morphir.IR.QName.QName"
            },
            {
                "name": "getLocalName",
                "comment": " Get the local name part of a qualified name.\n",
                "type": "Morphir.IR.QName.QName -> Morphir.IR.Name.Name"
            },
            {
                "name": "getModulePath",
                "comment": " Get the module path part of a qualified name.\n",
                "type": "Morphir.IR.QName.QName -> Morphir.IR.Path.Path"
            },
            {
                "name": "toString",
                "comment": " Turn a QName into a string using `:` as the separator between module and local names.\n\n    qname =\n        QName.fromTuple\n            (Path.fromList\n                [ Name.fromList [ \"foo\", \"bar\" ]\n                , Name.fromList [ \"baz\" ]\n                ]\n            , Name.fromList [ \"a\", \"name\" ]\n            )\n\n    toString qname\n    --> \"FooBar.Baz:aName\"\n\n",
                "type": "Morphir.IR.QName.QName -> String.String"
            },
            {
                "name": "toTuple",
                "comment": " Turn a qualified name into a tuple.\n",
                "type": "Morphir.IR.QName.QName -> ( Morphir.IR.Path.Path, Morphir.IR.Name.Name )"
            }
        ],
        "binops": []
    },
    {
        "name": "Morphir.IR.Type",
        "comment": " Like any other programming languages Morphir has a type system as well. This module defines the building blocks of\nthat type system. If you want to learn more about type systems check out\n[Wikipedia: Type system](https://en.wikipedia.org/wiki/Type_system).\n\nMorphir's type system is heavily inspired by Elm's type system so the best way to understand the building blocks here is\nthrough some Elm examples. Let's take this bit of Elm code as a starting point:\n\n    type alias MyInteger =\n        Int\n\n    type alias MyRecord a =\n        { foo : List a\n        }\n\n    type Foo a\n        = Bar a\n        | Baz\n\nThese would translate to type definitions in Morphir which is represented by the [`Definition`](#Definition) type.\nDefinitions themselves don't have a name. It's the Module that contains that information in the `types` dictionary as a\nkey. The type parameters and the right-hand side of the declaration is contained in the [`Definition`](#Definition) type\nitself. This is how the above would translate to the IR (some parts are omitted to reduce noise):\n\n    { types =\n        Dict.fromList\n            [ ( [ \"my\", \"integer\" ], TypeAliasDefinition [] (...) )\n            , ( [ \"my\", \"record\" ], TypeAliasDefinition [ [ \"a\" ] ] (...) )\n            , ( [ \"foo\" ], CustomTypeDefinition [ [ \"a\" ], [ \"b\" ] ] (...) )\n            ]\n    , values =\n        Dict.empty\n    }\n\nType aliases simply assign a new name to a type expression. This type expression can be a reference to another type or\na record type or any other type expression. Custom types are defined by a list of constructors. Each of those\nconstructors have a list of arguments. Each argument is a type expression.\n\nHere is the full definition for reference:\n\n    { types =\n        Dict.fromList\n            [ ( [ \"my\", \"integer\" ]\n              , TypeAliasDefinition []\n                    (Reference (fqn \"Morphir.SDK\" \"Basics\" \"Int\") [])\n              )\n            , ( [ \"my\", \"record\" ]\n              , TypeAliasDefinition [ [ \"a\" ] ]\n                    (Record ()\n                        [ Field [ \"foo\" ] (Reference () (fqn \"Morphir.SDK\" \"List\" \"List\") [ Variable () [ \"a\" ] ])\n                        ]\n                    )\n              )\n            , ( [ \"foo\" ]\n              , CustomTypeDefinition [ [ \"a\" ], [ \"b\" ] ]\n                    (AccessControlled.public\n                        [ Constructor [ \"bar\" ] [ ( [ \"arg\", \"1\" ], Variable () [ \"a\" ] ) ]\n                        , Constructor [ \"baz\" ] [ ( [ \"arg\", \"1\" ], Variable () [ \"b\" ] ) ]\n                        ]\n                    )\n              )\n            ]\n    , values =\n        Dict.empty\n    }\n\n\n# Type Expression\n\n@docs Type\n\n\n## Creation\n\n@docs variable, reference, tuple, record, extensibleRecord, function, unit\n\n\n# Record Field\n\n@docs Field, mapFieldName, mapFieldType\n\n\n# Specification\n\n@docs Specification, typeAliasSpecification, opaqueTypeSpecification, customTypeSpecification\n\n\n# Definition\n\n@docs Definition, typeAliasDefinition, customTypeDefinition, definitionToSpecification\n\n\n# Constructors\n\n@docs Constructors\n\n\n# Utilities\n\n@docs mapTypeAttributes, mapSpecificationAttributes, mapDefinitionAttributes, mapDefinition, typeAttributes\n\n@docs eraseAttributes, collectVariables, collectReferences, collectReferencesFromDefintion, substituteTypeVariables, toString\n\n",
        "unions": [
            {
                "name": "Definition",
                "comment": " This syntax represents a type definition. For example:\n\n  - `type alias Foo a = {bar : Maybe a, qux : Int}`\n  - `type MyList a = End | Cons a (MyList a)`\n\nIn the definition, the `List Name` refers to type parameters on the LHS\nand `Type extra` refers to the RHS\n\n",
                "args": [
                    "a"
                ],
                "cases": [
                    [
                        "TypeAliasDefinition",
                        [
                            "List.List Morphir.IR.Name.Name",
                            "Morphir.IR.Type.Type a"
                        ]
                    ],
                    [
                        "CustomTypeDefinition",
                        [
                            "List.List Morphir.IR.Name.Name",
                            "Morphir.IR.AccessControlled.AccessControlled (Morphir.IR.Type.Constructors a)"
                        ]
                    ]
                ]
            },
            {
                "name": "Specification",
                "comment": " ",
                "args": [
                    "a"
                ],
                "cases": [
                    [
                        "TypeAliasSpecification",
                        [
                            "List.List Morphir.IR.Name.Name",
                            "Morphir.IR.Type.Type a"
                        ]
                    ],
                    [
                        "OpaqueTypeSpecification",
                        [
                            "List.List Morphir.IR.Name.Name"
                        ]
                    ],
                    [
                        "CustomTypeSpecification",
                        [
                            "List.List Morphir.IR.Name.Name",
                            "Morphir.IR.Type.Constructors a"
                        ]
                    ]
                ]
            },
            {
                "name": "Type",
                "comment": " Represents a type expression that can appear in various places within the IR. It can be the right-hand-side of\na type alias declaration, input and output types of a function or as an annotation on values after type inference is\ndone.\n\nType are modeled as expression trees: a recursive data structure with various node types. The type argument `a` allows\nus to assign some additional attributes to each node in the tree. Here are some details on each node type in the tree:\n\n  - **Variable**\n      - Represents a type variable.\n      - It has a single argument which captures the name of the variable.\n      - [Wikipedia: Type variable](https://en.wikipedia.org/wiki/Type_variable)\n      - [creation](#variable), [matching](#matchVariable)\n  - **Reference**\n      - A fully-qualified reference to some other type or type alias within the package or one of its dependencies.\n      - References to built-in types (like `Int`, `String`, ...) don't have an associated definition.\n      - [creation](#reference), [matching](#matchReference)\n  - **Tuple**\n      - A tuple is a composition of other types (potentially other tuples).\n      - The order of types is relevant so the easiest way to think about it is as a list of types.\n      - A tuple can have any number of elements and there is no restriction on the element types.\n      - A tuple with zero elements is equivalent with `Unit`.\n      - A tuple with a single element is equivalent to the element type itself.\n      - [Wikipedia: Tuple](https://en.wikipedia.org/wiki/Tuple)\n      - [creation](#tuple), [matching](#matchTuple)\n  - **Record**\n      - A record is a composition of other types like tuples but types are identified by a field name instead of an index.\n      - The best way to think of a record is as a dictionary of types.\n      - Our representation captures the order of fields for convenience but the order should not be considered for type\n        equivalence.\n      - [Wikipedia: Record](https://en.wikipedia.org/wiki/Record_(computer_science))\n      - [Elm-lang: Records](https://elm-lang.org/docs/records)\n      - Utilities: [creation](#record), [matching](#matchRecord)\n  - **ExtensibleRecord**\n      - Similar to records but while record types declare that the underlying object has \"exactly these fields\" an\n        extensible record declares that the object has \"at least these fields\".\n      - Besides the list of fields you need to specify a variable name that will be used to abstract over the type\n        that's being extended.\n      - [Elm: Extensible records](https://ckoster22.medium.com/advanced-types-in-elm-extensible-records-67e9d804030d)\n      - [creation](#extensibleRecord), [matching](#matchExtensibleRecord)\n  - **Function**\n      - Represents the type of a function. The two arguments are the argument and the return type of the function.\n      - Multi-argument functions are represented by composing functions:\n          - `a -> b -> c` is represented as `a -> (b -> c)`\n      - [Wikipedia: Function type](https://en.wikipedia.org/wiki/Function_type)\n      - [creation](#function), [matching](#matchFunction)\n  - **Unit**\n      - Unit type is used as a placeholder in situations where a type is required but the corresponding value is unused.\n      - Semantically the unit type represents a set that has exactly one value which is often called unit.\n      - Unit corresponds to void in some other programming languages.\n      - [Wikipedia: Unit type](https://en.wikipedia.org/wiki/Unit_type)\n      - [creation](#unit), [matching](#matchUnit)\n\n",
                "args": [
                    "a"
                ],
                "cases": [
                    [
                        "Variable",
                        [
                            "a",
                            "Morphir.IR.Name.Name"
                        ]
                    ],
                    [
                        "Reference",
                        [
                            "a",
                            "Morphir.IR.FQName.FQName",
                            "List.List (Morphir.IR.Type.Type a)"
                        ]
                    ],
                    [
                        "Tuple",
                        [
                            "a",
                            "List.List (Morphir.IR.Type.Type a)"
                        ]
                    ],
                    [
                        "Record",
                        [
                            "a",
                            "List.List (Morphir.IR.Type.Field a)"
                        ]
                    ],
                    [
                        "ExtensibleRecord",
                        [
                            "a",
                            "Morphir.IR.Name.Name",
                            "List.List (Morphir.IR.Type.Field a)"
                        ]
                    ],
                    [
                        "Function",
                        [
                            "a",
                            "Morphir.IR.Type.Type a",
                            "Morphir.IR.Type.Type a"
                        ]
                    ],
                    [
                        "Unit",
                        [
                            "a"
                        ]
                    ]
                ]
            }
        ],
        "aliases": [
            {
                "name": "Constructors",
                "comment": " Constructors in a dictionary keyed by their name. The values are the argument types for each constructor.\n",
                "args": [
                    "a"
                ],
                "type": "Dict.Dict Morphir.IR.Name.Name (List.List ( Morphir.IR.Name.Name, Morphir.IR.Type.Type a ))"
            },
            {
                "name": "Field",
                "comment": " An opaque representation of a field. It's made up of a name and a type.\n",
                "args": [
                    "a"
                ],
                "type": "{ name : Morphir.IR.Name.Name, tpe : Morphir.IR.Type.Type a }"
            }
        ],
        "values": [
            {
                "name": "collectReferences",
                "comment": " Collect all references in a type recursively.\n",
                "type": "Morphir.IR.Type.Type ta -> Set.Set Morphir.IR.FQName.FQName"
            },
            {
                "name": "collectReferencesFromDefintion",
                "comment": " Collect references from a Type Definition\n",
                "type": "Morphir.IR.Type.Definition ta -> Set.Set Morphir.IR.FQName.FQName"
            },
            {
                "name": "collectVariables",
                "comment": " Collect all variables in a type recursively.\n",
                "type": "Morphir.IR.Type.Type ta -> Set.Set Morphir.IR.Name.Name"
            },
            {
                "name": "customTypeDefinition",
                "comment": " ",
                "type": "List.List Morphir.IR.Name.Name -> Morphir.IR.AccessControlled.AccessControlled (Morphir.IR.Type.Constructors a) -> Morphir.IR.Type.Definition a"
            },
            {
                "name": "customTypeSpecification",
                "comment": " ",
                "type": "List.List Morphir.IR.Name.Name -> Morphir.IR.Type.Constructors a -> Morphir.IR.Type.Specification a"
            },
            {
                "name": "definitionToSpecification",
                "comment": " ",
                "type": "Morphir.IR.Type.Definition a -> Morphir.IR.Type.Specification a"
            },
            {
                "name": "eraseAttributes",
                "comment": " ",
                "type": "Morphir.IR.Type.Definition a -> Morphir.IR.Type.Definition ()"
            },
            {
                "name": "extensibleRecord",
                "comment": " Creates an extensible record type.\n\n    toIR { e | foo = Int }\n        == extensibleRecord (variable [ \"e\" ])\n            [ field [ \"foo\" ] intType\n            ]\n\n    toIR { f | foo = Int, bar = Bool }\n        == extensibleRecord (variable [ \"f\" ])\n            [ field [ \"foo\" ] intType\n            , field [ \"bar\" ] boolType\n            ]\n\n",
                "type": "a -> Morphir.IR.Name.Name -> List.List (Morphir.IR.Type.Field a) -> Morphir.IR.Type.Type a"
            },
            {
                "name": "function",
                "comment": " Creates a function type. Use currying to create functions with more than one argument.\n\n    toIR (Int -> Bool) ==\n        function\n            SDK.Basics.intType\n            SDK.Basics.boolType\n\n    toIR (Int -> Bool -> Char) ==\n        function\n            intType\n            (function\n                SDK.Basics.boolType\n                SDK.Basics.charType\n            )\n\n",
                "type": "a -> Morphir.IR.Type.Type a -> Morphir.IR.Type.Type a -> Morphir.IR.Type.Type a"
            },
            {
                "name": "mapDefinition",
                "comment": " ",
                "type": "(Morphir.IR.Type.Type a -> Result.Result e (Morphir.IR.Type.Type b)) -> Morphir.IR.Type.Definition a -> Result.Result (List.List e) (Morphir.IR.Type.Definition b)"
            },
            {
                "name": "mapDefinitionAttributes",
                "comment": " ",
                "type": "(a -> b) -> Morphir.IR.Type.Definition a -> Morphir.IR.Type.Definition b"
            },
            {
                "name": "mapFieldName",
                "comment": " Map the name of the field to get a new field.\n",
                "type": "(Morphir.IR.Name.Name -> Morphir.IR.Name.Name) -> Morphir.IR.Type.Field a -> Morphir.IR.Type.Field a"
            },
            {
                "name": "mapFieldType",
                "comment": " Map the type of the field to get a new field.\n",
                "type": "(Morphir.IR.Type.Type a -> Morphir.IR.Type.Type b) -> Morphir.IR.Type.Field a -> Morphir.IR.Type.Field b"
            },
            {
                "name": "mapSpecificationAttributes",
                "comment": " ",
                "type": "(a -> b) -> Morphir.IR.Type.Specification a -> Morphir.IR.Type.Specification b"
            },
            {
                "name": "mapTypeAttributes",
                "comment": " ",
                "type": "(a -> b) -> Morphir.IR.Type.Type a -> Morphir.IR.Type.Type b"
            },
            {
                "name": "opaqueTypeSpecification",
                "comment": " ",
                "type": "List.List Morphir.IR.Name.Name -> Morphir.IR.Type.Specification a"
            },
            {
                "name": "record",
                "comment": " Creates a record type.\n\n    toIR {} == record []\n\n    toIR { foo = Int }\n        == record\n            [ field [ \"foo\" ] SDK.Basics.intType\n            ]\n\n    toIR { foo = Int, bar = Bool }\n        == record\n            [ field [ \"foo\" ] SDK.Basics.intType\n            , field [ \"bar\" ] SDK.Basics.boolType\n            ]\n\n",
                "type": "a -> List.List (Morphir.IR.Type.Field a) -> Morphir.IR.Type.Type a"
            },
            {
                "name": "reference",
                "comment": " Creates a fully-qualified reference to a type.\n\n    toIR (List Int)\n        == reference SDK.List.listType [ intType ]\n\n    toIR Foo.Bar\n        == reference\n            ( [ [ \"my\" ], [ \"lib\" ] ], [ [ \"foo\" ] ], [ \"bar\" ] )\n            []\n\n",
                "type": "a -> Morphir.IR.FQName.FQName -> List.List (Morphir.IR.Type.Type a) -> Morphir.IR.Type.Type a"
            },
            {
                "name": "substituteTypeVariables",
                "comment": " Substitute type variables recursively.\n",
                "type": "Dict.Dict Morphir.IR.Name.Name (Morphir.IR.Type.Type ta) -> Morphir.IR.Type.Type ta -> Morphir.IR.Type.Type ta"
            },
            {
                "name": "toString",
                "comment": " Get a compact string representation of the type.\n",
                "type": "Morphir.IR.Type.Type a -> String.String"
            },
            {
                "name": "tuple",
                "comment": " Creates a tuple type.\n\n    toIR ( Int, Bool )\n        == tuple [ basic intType, basic boolType ]\n\n",
                "type": "a -> List.List (Morphir.IR.Type.Type a) -> Morphir.IR.Type.Type a"
            },
            {
                "name": "typeAliasDefinition",
                "comment": " ",
                "type": "List.List Morphir.IR.Name.Name -> Morphir.IR.Type.Type a -> Morphir.IR.Type.Definition a"
            },
            {
                "name": "typeAliasSpecification",
                "comment": " ",
                "type": "List.List Morphir.IR.Name.Name -> Morphir.IR.Type.Type a -> Morphir.IR.Type.Specification a"
            },
            {
                "name": "typeAttributes",
                "comment": " ",
                "type": "Morphir.IR.Type.Type a -> a"
            },
            {
                "name": "unit",
                "comment": " Creates a unit type.\n\n    toIR () == unit\n\n",
                "type": "a -> Morphir.IR.Type.Type a"
            },
            {
                "name": "variable",
                "comment": " Creates a type variable.\n\n    toIR a == variable [ \"a\" ] ()\n\n    toIR fooBar == variable [ \"foo\", \"bar\" ] ()\n\n",
                "type": "a -> Morphir.IR.Name.Name -> Morphir.IR.Type.Type a"
            }
        ],
        "binops": []
    },
    {
        "name": "Morphir.IR.Value",
        "comment": " In functional programming data and logic are treated the same way and we refer to both as values. This module\nprovides the building blocks for those values (data and logic) in the Morphir IR.\n\nIf you use Elm as your frontend language for Morphir then you should think about all the logic and constant values that\nyou can put in the body of a function. Here are a few examples:\n\n    myThreshold =\n        1000\n\n    min a b =\n        if a < b then\n            a\n\n        else\n            b\n\n    addTwo a =\n        a + 2\n\nAll the above are values: the first one is just data, the second one is logic and the last one has both logic and data.\nIn either case each value is represented by a [`Value`](#Value) expression. This is a recursive data structure with\nvarious node types representing each possible language construct. You can check out the documentation for values below\nto find more details. Here are the Morphir IR snippets for the above values as a quick reference:\n\n    myThreshold =\n        Literal () (WholeNumberLiteral 1000)\n\n    min a b =\n        IfThenElse ()\n            (Apply ()\n                (Apply ()\n                    (Reference () (fqn \"Morphir.SDK\" \"Basics\" \"lessThan\"))\n                    (Variable () [ \"a\" ])\n                )\n                (Variable () [ \"b\" ])\n            )\n            (Variable () [ \"a\" ])\n            (Variable () [ \"b\" ])\n\n    addTwo a =\n        Apply ()\n            (Apply ()\n                (Reference () (fqn \"Morphir.SDK\" \"Basics\" \"add\"))\n                (Variable () [ \"a\" ])\n            )\n            (Literal () (WholeNumberLiteral 2))\n\n\n# Value\n\nValue is the top level building block for data and logic. See the constructor functions below for details on each node type.\n\n@docs Value, RawValue, TypedValue, literal, constructor, apply, field, fieldFunction, lambda, letDef, letDestruct, letRec, list, record, reference\n@docs tuple, variable, ifThenElse, patternMatch, update, unit\n@docs mapValueAttributes\n\n\n# Pattern\n\nPatterns are used in multiple ways in the IR: they can take apart a structured value into smaller pieces (destructure) and they\ncan also filter values. The combination of these two features creates a very powerful method tool that can be used in two ways:\ndestructuring and pattern-matching. Pattern-matching is a combination of destructuring, filtering and branching.\n\n@docs Pattern, wildcardPattern, asPattern, tuplePattern, constructorPattern, emptyListPattern, headTailPattern, literalPattern\n\n\n# Specification\n\nThe specification of what the value or function\nis without the actual data or logic behind it.\n\n@docs Specification, mapSpecificationAttributes\n\n\n# Definition\n\nA definition is the actual data or logic as opposed to a specification\nwhich is just the specification of those. Value definitions can be typed or untyped. Exposed values have to be typed.\n\n@docs Definition, mapDefinition, mapDefinitionAttributes\n\n\n# Utilities\n\n@docs definitionToSpecification, typeAndValueToDefinition, uncurryApply, collectVariables, collectReferences, collectDefinitionAttributes, collectPatternAttributes\n@docs collectValueAttributes, indexedMapPattern, indexedMapValue, mapPatternAttributes, patternAttribute, valueAttribute\n@docs definitionToValue, rewriteValue, toRawValue, countValueNodes, collectPatternVariables, isData, toString\n\n",
        "unions": [
            {
                "name": "Pattern",
                "comment": " Type that represents a pattern. A pattern can do two things: match on a specific shape or exact value and extract\nparts of a value into variables. It's a recursive data structure made of of the following building blocks:\n\n  - **WildcardPattern**\n      - Matches any value and does not extract any variables.\n      - `_` in Elm\n  - **AsPattern**\n      - Assigns a variable name to the value matched by a nested pattern.\n      - `(...) as foo` in Elm\n      - Special case: when there is just a variable name in a pattern in Elm it will be represented as a\n        `WildcardPattern` wrapped in an `AsPattern`\n  - **TuplePattern**\n      - Matches on a tuple where each element matches the nested patterns.\n  - **ConstructorPattern**\n      - Matches on a type constructor and its arguments.\n  - **EmptyListPattern**\n      - Matches on an empty list.\n  - **HeadTailPattern**\n      - Matches on the head and the tail of a list.\n      - Combined with `EmptyListPattern` it can match on lists of any specific sizes.\n  - **LiteralPattern**\n      - Matches an an exact literal value.\n  - **UnitPattern**\n      - Matches the `Unit` value only.\n\n",
                "args": [
                    "a"
                ],
                "cases": [
                    [
                        "WildcardPattern",
                        [
                            "a"
                        ]
                    ],
                    [
                        "AsPattern",
                        [
                            "a",
                            "Morphir.IR.Value.Pattern a",
                            "Morphir.IR.Name.Name"
                        ]
                    ],
                    [
                        "TuplePattern",
                        [
                            "a",
                            "List.List (Morphir.IR.Value.Pattern a)"
                        ]
                    ],
                    [
                        "ConstructorPattern",
                        [
                            "a",
                            "Morphir.IR.FQName.FQName",
                            "List.List (Morphir.IR.Value.Pattern a)"
                        ]
                    ],
                    [
                        "EmptyListPattern",
                        [
                            "a"
                        ]
                    ],
                    [
                        "HeadTailPattern",
                        [
                            "a",
                            "Morphir.IR.Value.Pattern a",
                            "Morphir.IR.Value.Pattern a"
                        ]
                    ],
                    [
                        "LiteralPattern",
                        [
                            "a",
                            "Morphir.IR.Literal.Literal"
                        ]
                    ],
                    [
                        "UnitPattern",
                        [
                            "a"
                        ]
                    ]
                ]
            },
            {
                "name": "Value",
                "comment": " Type that represents a value expression. This is a recursive data structure with various node types representing\neach possible language construct.\n\nThe extra type parameters `ta` and `va` allow you to add type and value attributes. Type attributes allow you to add\nextra information to each type node. Value attributes do the same for value nodes. In many cases you might not need this\nin which case you can just put a unit (`()`) type or a type variable as a placeholder.\n\nThese are the supported node types:\n\n  - **Literal**\n      - Represents a literal value like 13, True or \"foo\".\n      - See the documentation in the [Literal](Morphir-IR-Literal) module for details on the supported literal types.\n      - See [Wikipedia: Literal](https://en.wikipedia.org/wiki/Literal_(computer_programming)) for more details on\n        literals.\n  - **Constructor**\n      - Reference to a custom type constructor name.\n      - If the type constructor has arguments this node will be wrapped into some `Apply` nodes depending on the number\n        of arguments.\n  - **Tuple**\n      - Represents a tuple value.\n      - Each element of the tuple is in turn a `Value`.\n  - **List**\n      - Represents a list of values.\n      - Each item of the list is in turn a `Value`.\n  - **Record**\n      - Represents a record value.\n      - Each field value of the record is in turn a `Value`.\n  - **Variable**\n      - Reference to a variable.\n  - **Reference**\n      - Reference to another value within or outside the module.\n      - References are always full-qualified to make resolution easier.\n  - **Field**\n      - Represents accessing a field on a record together with the target expression.\n      - This is done using the dot notation in Elm: `foo.bar`\n  - **FieldFunction**\n      - Represents accessing a field on a record without the target expression.\n      - This is a shortcut to refer to the function that extracts the field from the input.\n      - This is done using the dot notation in Elm without a target expression: `.bar`\n  - **Apply**\n      - Represents a function application.\n      - The two arguments are the target function and the argument.\n      - Multi-argument invocations are expressed by wrapping multiple `Apply` nodes in each other (currying).\n  - **Lambda**\n      - Represents a lambda abstraction.\n      - The first argument is a pattern to match on the input, the second is the lambda expression's body.\n  - **LetDefinition**\n      - Represents a single let binding.\n      - Multiple let bindings are achieved through wrapping multiple let expressions into each other.\n  - **LetRecursion**\n      - Special let binding that allows mutual recursion between the bindings.\n      - This is necessary because `LetDefinition` will not make recursion possible due to its scoping rules.\n  - **Destructure**\n      - Applies a pattern match to the first expression and passes any extracted variables to the second expression.\n      - This can be represented as a let expression with a pattern binding or a single-case pattern-match in Elm.\n  - **IfThenElse**\n      - Represents a simple if/then/else expression.\n      - The 3 arguments are: the condition, the then branch and the else branch.\n  - **PatternMatch**\n      - Represents a pattern-match.\n  - **UpdateRecord**\n      - Expression to update one or more fields of a record.\n      - As usual in FP this is a copy-on-update so no mutation is happening.\n  - **Unit**\n      - Represents the single value in the Unit type.\n      - When you find Unit in the IR it usually means: \"There's nothing useful here\".\n\n",
                "args": [
                    "ta",
                    "va"
                ],
                "cases": [
                    [
                        "Literal",
                        [
                            "va",
                            "Morphir.IR.Literal.Literal"
                        ]
                    ],
                    [
                        "Constructor",
                        [
                            "va",
                            "Morphir.IR.FQName.FQName"
                        ]
                    ],
                    [
                        "Tuple",
                        [
                            "va",
                            "List.List (Morphir.IR.Value.Value ta va)"
                        ]
                    ],
                    [
                        "List",
                        [
                            "va",
                            "List.List (Morphir.IR.Value.Value ta va)"
                        ]
                    ],
                    [
                        "Record",
                        [
                            "va",
                            "Dict.Dict Morphir.IR.Name.Name (Morphir.IR.Value.Value ta va)"
                        ]
                    ],
                    [
                        "Variable",
                        [
                            "va",
                            "Morphir.IR.Name.Name"
                        ]
                    ],
                    [
                        "Reference",
                        [
                            "va",
                            "Morphir.IR.FQName.FQName"
                        ]
                    ],
                    [
                        "Field",
                        [
                            "va",
                            "Morphir.IR.Value.Value ta va",
                            "Morphir.IR.Name.Name"
                        ]
                    ],
                    [
                        "FieldFunction",
                        [
                            "va",
                            "Morphir.IR.Name.Name"
                        ]
                    ],
                    [
                        "Apply",
                        [
                            "va",
                            "Morphir.IR.Value.Value ta va",
                            "Morphir.IR.Value.Value ta va"
                        ]
                    ],
                    [
                        "Lambda",
                        [
                            "va",
                            "Morphir.IR.Value.Pattern va",
                            "Morphir.IR.Value.Value ta va"
                        ]
                    ],
                    [
                        "LetDefinition",
                        [
                            "va",
                            "Morphir.IR.Name.Name",
                            "Morphir.IR.Value.Definition ta va",
                            "Morphir.IR.Value.Value ta va"
                        ]
                    ],
                    [
                        "LetRecursion",
                        [
                            "va",
                            "Dict.Dict Morphir.IR.Name.Name (Morphir.IR.Value.Definition ta va)",
                            "Morphir.IR.Value.Value ta va"
                        ]
                    ],
                    [
                        "Destructure",
                        [
                            "va",
                            "Morphir.IR.Value.Pattern va",
                            "Morphir.IR.Value.Value ta va",
                            "Morphir.IR.Value.Value ta va"
                        ]
                    ],
                    [
                        "IfThenElse",
                        [
                            "va",
                            "Morphir.IR.Value.Value ta va",
                            "Morphir.IR.Value.Value ta va",
                            "Morphir.IR.Value.Value ta va"
                        ]
                    ],
                    [
                        "PatternMatch",
                        [
                            "va",
                            "Morphir.IR.Value.Value ta va",
                            "List.List ( Morphir.IR.Value.Pattern va, Morphir.IR.Value.Value ta va )"
                        ]
                    ],
                    [
                        "UpdateRecord",
                        [
                            "va",
                            "Morphir.IR.Value.Value ta va",
                            "Dict.Dict Morphir.IR.Name.Name (Morphir.IR.Value.Value ta va)"
                        ]
                    ],
                    [
                        "Unit",
                        [
                            "va"
                        ]
                    ]
                ]
            }
        ],
        "aliases": [
            {
                "name": "Definition",
                "comment": " Type that represents a value or function definition. A definition is the actual data or logic as opposed to a specification\nwhich is just the specification of those. Value definitions can be typed or untyped. Exposed values have to be typed.\n",
                "args": [
                    "ta",
                    "va"
                ],
                "type": "{ inputTypes : List.List ( Morphir.IR.Name.Name, va, Morphir.IR.Type.Type ta ), outputType : Morphir.IR.Type.Type ta, body : Morphir.IR.Value.Value ta va }"
            },
            {
                "name": "RawValue",
                "comment": " A value without any additional information.\n",
                "args": [],
                "type": "Morphir.IR.Value.Value () ()"
            },
            {
                "name": "Specification",
                "comment": " Type that represents a value or function specification. The specification of what the value or function\nis without the actual data or logic behind it.\n",
                "args": [
                    "ta"
                ],
                "type": "{ inputs : List.List ( Morphir.IR.Name.Name, Morphir.IR.Type.Type ta ), output : Morphir.IR.Type.Type ta }"
            },
            {
                "name": "TypedValue",
                "comment": " A value with type information.\n",
                "args": [],
                "type": "Morphir.IR.Value.Value () (Morphir.IR.Type.Type ())"
            }
        ],
        "values": [
            {
                "name": "apply",
                "comment": " Represents a function invocation. We use currying to represent function invocations with multiple arguments.\n\n**Note**: Operators are mapped to well-known function names.\n\n    not True -- Apply (Reference ( ..., [ [ \"basics\" ] ], [ \"not\" ])) (Literal (BoolLiteral True))\n\n    True || False -- Apply (Apply (Reference ( ..., [ [ \"basics\" ] ], [ \"and\" ]))) (Literal (BoolLiteral True)) (Literal (BoolLiteral True))\n\n",
                "type": "va -> Morphir.IR.Value.Value ta va -> Morphir.IR.Value.Value ta va -> Morphir.IR.Value.Value ta va"
            },
            {
                "name": "asPattern",
                "comment": " Assigns a variable name to a pattern.\n\n    _ as foo -- AsPattern WildcardPattern [\"foo\"]\n\n    foo -- AsPattern WildcardPattern [\"foo\"]\n\n    [] as foo -- AsPattern EmptyListPattern [\"foo\"]\n\n",
                "type": "a -> Morphir.IR.Value.Pattern a -> Morphir.IR.Name.Name -> Morphir.IR.Value.Pattern a"
            },
            {
                "name": "collectDefinitionAttributes",
                "comment": " ",
                "type": "Morphir.IR.Value.Definition ta va -> List.List va"
            },
            {
                "name": "collectPatternAttributes",
                "comment": " ",
                "type": "Morphir.IR.Value.Pattern a -> List.List a"
            },
            {
                "name": "collectPatternVariables",
                "comment": " Collect all variables in a pattern.\n",
                "type": "Morphir.IR.Value.Pattern va -> Set.Set Morphir.IR.Name.Name"
            },
            {
                "name": "collectReferences",
                "comment": " Collect all references in a value recursively.\n",
                "type": "Morphir.IR.Value.Value ta va -> Set.Set Morphir.IR.FQName.FQName"
            },
            {
                "name": "collectValueAttributes",
                "comment": " ",
                "type": "Morphir.IR.Value.Value ta va -> List.List va"
            },
            {
                "name": "collectVariables",
                "comment": " Collect all variables in a value recursively.\n",
                "type": "Morphir.IR.Value.Value ta va -> Set.Set Morphir.IR.Name.Name"
            },
            {
                "name": "constructor",
                "comment": " A reference to a constructor of a custom type.\n\n    Nothing -- Constructor ( ..., [ [ \"maybe\" ] ], [ \"nothing\" ] )\n\n    Foo.Bar -- Constructor ( ..., [ [ \"foo\" ] ], [ \"bar\" ] )\n\n",
                "type": "va -> Morphir.IR.FQName.FQName -> Morphir.IR.Value.Value ta va"
            },
            {
                "name": "constructorPattern",
                "comment": " Matches on a custom type's constructor.\n\n**Note**: When the custom type has a single constructor this can be used for destructuring.\nWhen there are multiple constructors it also does filtering so it cannot be used in a\n[`LetDestruct`](#letDestruct) but it can be used in a [pattern-match](#patternMatch).\n\n    Just _ -- ConstructorPattern ( ..., [[\"maybe\"]], [\"just\"]) [ WildcardPattern ]\n\n",
                "type": "a -> Morphir.IR.FQName.FQName -> List.List (Morphir.IR.Value.Pattern a) -> Morphir.IR.Value.Pattern a"
            },
            {
                "name": "countValueNodes",
                "comment": " ",
                "type": "Morphir.IR.Value.Value ta va -> Basics.Int"
            },
            {
                "name": "definitionToSpecification",
                "comment": " Turns a definition into a specification by removing implementation details.\n",
                "type": "Morphir.IR.Value.Definition ta va -> Morphir.IR.Value.Specification ta"
            },
            {
                "name": "definitionToValue",
                "comment": " Turn a value definition into a value by wrapping the body value as needed based on the number of arguments the\ndefinition has. For example, if the definition specifies 2 inputs it will wrap the body into 2 lambdas each taking one\nargument:\n\n    definitionToValue\n        (Definition\n            { inputTypes =\n                [ ( [ \"foo\" ], (), intType () )\n                , ( [ \"bar\" ], (), intType () )\n                ]\n            , outputType =\n                intType ()\n            , body =\n                Tuple () [ Variable () [ \"foo\" ], Variable () [ \"bar\" ] ]\n            }\n        )\n    -- Lambda (AsPattern () (WildcardPattern ()) [ \"foo\" ])\n    --     (Lambda (AsPattern () (WildcardPattern ()) [ \"bar\" ])\n    --         (Tuple () [ Variable () [ \"foo\" ], Variable () [ \"bar\" ] ])\n    --     )\n\n",
                "type": "Morphir.IR.Value.Definition ta va -> Morphir.IR.Value.Value ta va"
            },
            {
                "name": "emptyListPattern",
                "comment": " Matches an empty list. Can be used standalon but frequently used as a terminal pattern\nin a [`HeadTailPattern`](#headTailPattern).\n\n    [] -- EmptyListPattern\n\n    [ _ ]\n    -- HeadTailPattern\n    --     WildcardPattern\n    --     EmptyListPattern\n\n",
                "type": "a -> Morphir.IR.Value.Pattern a"
            },
            {
                "name": "field",
                "comment": " Extracts the value of a record's field.\n\n    a.foo -- Field (Variable [ \"a\" ]) [ \"foo\" ]\n\n",
                "type": "va -> Morphir.IR.Value.Value ta va -> Morphir.IR.Name.Name -> Morphir.IR.Value.Value ta va"
            },
            {
                "name": "fieldFunction",
                "comment": " Represents a function that extract a field from a record value passed to it.\n\n    .foo -- FieldFunction [ \"foo\" ]\n\n",
                "type": "va -> Morphir.IR.Name.Name -> Morphir.IR.Value.Value ta va"
            },
            {
                "name": "headTailPattern",
                "comment": " Matches the head and the tail of a list. It can be used to match lists of at least N items\nby nesting this pattern N times and terminating with [`EmptyListPattern`](#emptyListPattern).\n\n    [ a ]\n    -- HeadTailPattern\n    --     (AsPattern WildcardPattern [\"a\"])\n    --     EmptyListPattern\n\n    a :: b\n    -- HeadTailPattern\n    --     (AsPattern WildcardPattern [\"a\"])\n    --     (AsPattern WildcardPattern [\"b\"])\n\n    [ a, b ]\n    -- HeadTailPattern\n    --     (AsPattern WildcardPattern [\"a\"])\n    --     (HeadTailPattern\n    --         (AsPattern WildcardPattern [\"b\"])\n    --         EmptyListPattern\n    --     )\n\n",
                "type": "a -> Morphir.IR.Value.Pattern a -> Morphir.IR.Value.Pattern a -> Morphir.IR.Value.Pattern a"
            },
            {
                "name": "ifThenElse",
                "comment": " Represents and if/then/else expression.\n\n    if a then\n        b\n    else\n        c\n    -- IfThenElse (Variable [\"a\"])\n    --     (Variable [\"b\"])\n    --     (Variable [\"c\"])\n\n",
                "type": "va -> Morphir.IR.Value.Value ta va -> Morphir.IR.Value.Value ta va -> Morphir.IR.Value.Value ta va -> Morphir.IR.Value.Value ta va"
            },
            {
                "name": "indexedMapPattern",
                "comment": " Map attributes of a pattern while supplying an index to the map function. The index is incremented depth first.\n",
                "type": "(Basics.Int -> a -> b) -> Basics.Int -> Morphir.IR.Value.Pattern a -> ( Morphir.IR.Value.Pattern b, Basics.Int )"
            },
            {
                "name": "indexedMapValue",
                "comment": " Map attributes of a value while supplying an index to the map function. The index is incremented depth first.\n",
                "type": "(Basics.Int -> a -> b) -> Basics.Int -> Morphir.IR.Value.Value ta a -> ( Morphir.IR.Value.Value ta b, Basics.Int )"
            },
            {
                "name": "isData",
                "comment": " Check if the value has any logic in it all is all just data.\n",
                "type": "Morphir.IR.Value.Value ta va -> Basics.Bool"
            },
            {
                "name": "lambda",
                "comment": " Represents a lambda abstraction.\n\n**Note**:\n\n  - We use currying to represent lambda abstractions with multiple arguments.\n  - Arguments are not just names, they are patterns.\n\n```\n\\a -> a -- Lambda (AsPattern WildcardPattern [ \"a\" ]) (Variable [ \"a\" ])\n\n\\a b -> a -- Lambda (AsPattern WildcardPattern [ \"a\" ]) (Lambda (AsPattern WildcardPattern [ \"b\" ]) (Variable [ \"a\" ]))\n```\n\n",
                "type": "va -> Morphir.IR.Value.Pattern va -> Morphir.IR.Value.Value ta va -> Morphir.IR.Value.Value ta va"
            },
            {
                "name": "letDef",
                "comment": " Represents a let expression that assigns a value (and optionally type) to a name.\n\n**Note**: We use currying to represent let expressions with multiple name bindings.\n\n    let\n        a =\n            b\n    in\n    a\n    -- LetDef [ \"a\" ]\n    --     (UntypedDefinition [] (Variable [ \"b\" ]))\n    --     (Variable [ \"a\" ])\n\n    let\n        a : Bool\n        a =\n            b\n\n        c x =\n            a\n    in\n    c\n    -- LetDef [ \"a\" ]\n    --     (TypedDefinition (Basic BoolType) [] (Variable [ \"b\" ]))\n    --     (LetDef [ \"c\" ]\n    --         (UntypedDefinition [ [ \"x\" ] ] (Variable [ \"a\" ]))\n    --         (Variable [ \"c\" ])\n    --     )\n\n",
                "type": "va -> Morphir.IR.Name.Name -> Morphir.IR.Value.Definition ta va -> Morphir.IR.Value.Value ta va -> Morphir.IR.Value.Value ta va"
            },
            {
                "name": "letDestruct",
                "comment": " Represents a let expression that extracts values using a pattern.\n\n    let\n        ( a, b ) =\n            c\n    in\n    a\n    -- LetDestruct\n    --     (TuplePattern [ AsPattern WildcardPattern [\"a\"], AsPattern WildcardPattern [\"b\"] ])\n    --     (Variable [\"a\"])\n\n",
                "type": "va -> Morphir.IR.Value.Pattern va -> Morphir.IR.Value.Value ta va -> Morphir.IR.Value.Value ta va -> Morphir.IR.Value.Value ta va"
            },
            {
                "name": "letRec",
                "comment": " Represents a let expression with one or many recursive definitions.\n\n    let\n        a =\n            b\n\n        b =\n            a\n    in\n    a\n    -- LetRec\n    --     [ ( [ \"a\" ], UntypedDefinition [] (Variable [ \"b\" ]) )\n    --     , ( [ \"b\" ], UntypedDefinition [] (Variable [ \"a\" ]) )\n    --     ]\n    --     (Variable [ \"a\" ])\n\n",
                "type": "va -> Dict.Dict Morphir.IR.Name.Name (Morphir.IR.Value.Definition ta va) -> Morphir.IR.Value.Value ta va -> Morphir.IR.Value.Value ta va"
            },
            {
                "name": "list",
                "comment": " A [list] represents an ordered list of values where every value has to be of the same type.\n\n    [ 1, 3, 5 ] -- List [ Literal (WholeNumberLiteral 1), Literal (WholeNumberLiteral 3), Literal (WholeNumberLiteral 5) ]\n\n    [] -- List []\n\n[list]: https://en.wikipedia.org/wiki/List_(abstract_data_type)\n\n",
                "type": "va -> List.List (Morphir.IR.Value.Value ta va) -> Morphir.IR.Value.Value ta va"
            },
            {
                "name": "literal",
                "comment": " A [literal][lit] represents a fixed value in the IR. We only allow values of basic types: bool, char, string, int, float.\n\n    True -- Literal (BoolLiteral True)\n\n    'a' -- Literal (CharLiteral 'a')\n\n    \"foo\" -- Literal (StringLiteral \"foo\")\n\n    13 -- Literal (WholeNumberLiteral 13)\n\n    15.4 -- Literal (FloatLiteral 15.4)\n\n[lit]: https://en.wikipedia.org/wiki/Literal_(computer_programming)\n\n",
                "type": "va -> Morphir.IR.Literal.Literal -> Morphir.IR.Value.Value ta va"
            },
            {
                "name": "literalPattern",
                "comment": " Matches a specific literal value. This pattern can only be used in a [pattern-match](#patternMatch)\nsince it always filters.\n\n    True -- LiteralPattern (BoolLiteral True)\n\n    'a' -- LiteralPattern (CharLiteral 'a')\n\n    \"foo\" -- LiteralPattern (StringLiteral \"foo\")\n\n    13 -- LiteralPattern (WholeNumberLiteral 13)\n\n    15.4 -- LiteralPattern (FloatLiteral 15.4)\n\n",
                "type": "a -> Morphir.IR.Literal.Literal -> Morphir.IR.Value.Pattern a"
            },
            {
                "name": "mapDefinition",
                "comment": " ",
                "type": "(Morphir.IR.Type.Type ta -> Result.Result e (Morphir.IR.Type.Type ta)) -> (Morphir.IR.Value.Value ta va -> Result.Result e (Morphir.IR.Value.Value ta va)) -> Morphir.IR.Value.Definition ta va -> Result.Result (List.List e) (Morphir.IR.Value.Definition ta va)"
            },
            {
                "name": "mapDefinitionAttributes",
                "comment": " ",
                "type": "(ta -> tb) -> (va -> vb) -> Morphir.IR.Value.Definition ta va -> Morphir.IR.Value.Definition tb vb"
            },
            {
                "name": "mapPatternAttributes",
                "comment": " ",
                "type": "(a -> b) -> Morphir.IR.Value.Pattern a -> Morphir.IR.Value.Pattern b"
            },
            {
                "name": "mapSpecificationAttributes",
                "comment": " ",
                "type": "(a -> b) -> Morphir.IR.Value.Specification a -> Morphir.IR.Value.Specification b"
            },
            {
                "name": "mapValueAttributes",
                "comment": " ",
                "type": "(ta -> tb) -> (va -> vb) -> Morphir.IR.Value.Value ta va -> Morphir.IR.Value.Value tb vb"
            },
            {
                "name": "patternAttribute",
                "comment": " ",
                "type": "Morphir.IR.Value.Pattern a -> a"
            },
            {
                "name": "patternMatch",
                "comment": " Represents a pattern-match.\n\n    case a of\n        1 ->\n            \"yea\"\n\n        _ ->\n            \"nay\"\n    -- PatternMatch (Variable [\"a\"])\n    --     [ ( LiteralPattern (WholeNumberLiteral 1), Literal (StringLiteral \"yea\") )\n    --     , ( WildcardPattern, Literal (StringLiteral \"nay\") )\n    --     ]\n\n",
                "type": "va -> Morphir.IR.Value.Value ta va -> List.List ( Morphir.IR.Value.Pattern va, Morphir.IR.Value.Value ta va ) -> Morphir.IR.Value.Value ta va"
            },
            {
                "name": "record",
                "comment": " A [record] represents a dictionary of fields where the keys are the field names, and the values are the field values\n\n    { foo = \"bar\" } -- Record [ ( [ \"foo\" ], Literal (StringLiteral \"bar\") ) ]\n\n    { foo = \"bar\", baz = 1 } -- Record [ ( [ \"foo\" ], Literal (StringLiteral \"bar\") ), ( [ \"baz\" ], Literal (WholeNumberLiteral 1) ) ]\n\n    {} -- Record []\n\n[record]: https://en.wikipedia.org/wiki/Record_(computer_science)\n\n",
                "type": "va -> Dict.Dict Morphir.IR.Name.Name (Morphir.IR.Value.Value ta va) -> Morphir.IR.Value.Value ta va"
            },
            {
                "name": "reference",
                "comment": " A reference that refers to a function or a value with its fully-qualified name.\n\n    List.map -- Reference ( [ ..., [ [ \"list\" ] ], [ \"map\" ] )\n\n",
                "type": "va -> Morphir.IR.FQName.FQName -> Morphir.IR.Value.Value ta va"
            },
            {
                "name": "rewriteValue",
                "comment": " Recursively rewrite a value using the supplied mapping function.\n",
                "type": "(Morphir.IR.Value.Value ta va -> Maybe.Maybe (Morphir.IR.Value.Value ta va)) -> Morphir.IR.Value.Value ta va -> Morphir.IR.Value.Value ta va"
            },
            {
                "name": "toRawValue",
                "comment": " Clear all type and value annotations to get a raw value.\n",
                "type": "Morphir.IR.Value.Value ta va -> Morphir.IR.Value.RawValue"
            },
            {
                "name": "toString",
                "comment": " Simple string version of a value tree. The output is mostly compatible with the Elm syntax except where Elm uses\nindentation to separate values. This representation uses semicolons in those places.\n",
                "type": "Morphir.IR.Value.Value ta va -> String.String"
            },
            {
                "name": "tuple",
                "comment": " A [tuple] represents an ordered list of values where each value can be of a different type.\n\n**Note**: Tuples with zero values are considered to be the special value [`Unit`](#unit)\n\n    ( 1, True ) -- Tuple [ Literal (WholeNumberLiteral 1), Literal (BoolLiteral True) ]\n\n    ( \"foo\", True, 3 ) -- Tuple [ Literal (StringLiteral \"foo\"), Literal (BoolLiteral True), Literal (WholeNumberLiteral 3) ]\n\n    () -- Unit\n\n[tuple]: https://en.wikipedia.org/wiki/Tuple\n\n",
                "type": "va -> List.List (Morphir.IR.Value.Value ta va) -> Morphir.IR.Value.Value ta va"
            },
            {
                "name": "tuplePattern",
                "comment": " Destructures a tuple using a pattern for every element.\n\n    ( _, foo ) -- TuplePattern [ WildcardPattern, AsPattern WildcardPattern [\"foo\"] ]\n\n",
                "type": "a -> List.List (Morphir.IR.Value.Pattern a) -> Morphir.IR.Value.Pattern a"
            },
            {
                "name": "typeAndValueToDefinition",
                "comment": " Moves lambda arguments into function arguments as much as possible. For example given this function definition:\n\n    foo : Int -> Bool -> ( Int, Int ) -> String\n    foo =\n        \\a ->\n            \\b ->\n                ( c, d ) ->\n                    doSomething a b c d\n\nIt turns it into the following:\n\n    foo : Int -> Bool -> ( Int, Int ) -> String\n    foo a b =\n        ( c, d ) ->\n            doSomething a b c d\n\n",
                "type": "Morphir.IR.Type.Type ta -> Morphir.IR.Value.Value ta va -> Morphir.IR.Value.Definition ta va"
            },
            {
                "name": "uncurryApply",
                "comment": " Extract the argument list from a curried apply tree. It takes the two arguments of an apply and returns a tuple of\nthe function and a list of arguments.\n\n    uncurryApply (Apply () f a) b == ( f, [ a, b ] )\n\n",
                "type": "Morphir.IR.Value.Value ta va -> Morphir.IR.Value.Value ta va -> ( Morphir.IR.Value.Value ta va, List.List (Morphir.IR.Value.Value ta va) )"
            },
            {
                "name": "unit",
                "comment": " Represents the unit value.\n\n    () -- Unit\n\n",
                "type": "va -> Morphir.IR.Value.Value ta va"
            },
            {
                "name": "update",
                "comment": " Update one or many fields of a record value.\n\n    { a | foo = 1 } -- Update (Variable [\"a\"]) [ ( [\"foo\"], Literal (WholeNumberLiteral 1) ) ]\n\n",
                "type": "va -> Morphir.IR.Value.Value ta va -> Dict.Dict Morphir.IR.Name.Name (Morphir.IR.Value.Value ta va) -> Morphir.IR.Value.Value ta va"
            },
            {
                "name": "valueAttribute",
                "comment": " ",
                "type": "Morphir.IR.Value.Value ta va -> va"
            },
            {
                "name": "variable",
                "comment": " A [variable] represents a reference to a named value in the scope.\n\n    a -- Variable [ \"a\" ]\n\n    fooBar15 -- Variable [ \"foo\", \"bar\", \"15\" ]\n\n[variable]: https://en.wikipedia.org/wiki/Variable_(computer_science)\n\n",
                "type": "va -> Morphir.IR.Name.Name -> Morphir.IR.Value.Value ta va"
            },
            {
                "name": "wildcardPattern",
                "comment": " Matches any value and ignores it (assigns no variable name).\n\n    _ -- WildcardPattern\n\n",
                "type": "a -> Morphir.IR.Value.Pattern a"
            }
        ],
        "binops": []
    },
    {
        "name": "Morphir.Metadata",
        "comment": " The Metadata module analyses a distribution for the type of metadata information that would be helpful in\nautomating things like data dictionaries, lineage tracking, and the such.\n\n\n# Types\n\n@docs BaseTypes, EnumExtensionComponent, Enums, Modules, Types, Aliases, Metadata, UnionTypes\n\n\n# Processing\n\n@docs mapDistribution\n\n\n# Utilities\n\n@docs getTypes, getEnums, getBaseTypes, getAliases, getDocumentation, getModules, getEnumsWithExtensions, enumExtensionName, getUnions, isEnumExtension\n\n",
        "unions": [
            {
                "name": "EnumExtensionComponent",
                "comment": " An enum extension is a special pattern of union type that is either an enum or a name with no arguments\n",
                "args": [],
                "cases": []
            },
            {
                "name": "Metadata",
                "comment": " Structure for holding metadata information from processing the distribution.\n",
                "args": [
                    "ta"
                ],
                "cases": []
            }
        ],
        "aliases": [
            {
                "name": "Aliases",
                "comment": " The registry of aliases through the entire distribution.\nAn alias is any type alias that aliases a non-record type.\n",
                "args": [],
                "type": "Dict.Dict Morphir.IR.FQName.FQName Morphir.IR.FQName.FQName"
            },
            {
                "name": "BaseTypes",
                "comment": " The registry of base types through the entire distribution.\nA base type is any union type that has only one single-argument option.\n",
                "args": [],
                "type": "Dict.Dict Morphir.IR.FQName.FQName Morphir.IR.FQName.FQName"
            },
            {
                "name": "Enums",
                "comment": " The registry of enums through the entire distribution.\nAn enum is identified as any union type that has only non-argument options.\n",
                "args": [],
                "type": "Dict.Dict Morphir.IR.FQName.FQName (List.List Morphir.IR.Name.Name)"
            },
            {
                "name": "Modules",
                "comment": " The registry of modules through entire distribution.\n",
                "args": [],
                "type": "List.List Morphir.IR.Module.ModuleName"
            },
            {
                "name": "Types",
                "comment": " The registry of types through entire distribution.\n",
                "args": [
                    "ta"
                ],
                "type": "Dict.Dict Morphir.IR.FQName.FQName (Morphir.Scala.AST.Documented (Morphir.IR.Type.Definition ta))"
            },
            {
                "name": "UnionTypes",
                "comment": " The registry of union types through the entire distribution.\nA union type is any ADT that has more than one single-argument option.\n",
                "args": [
                    "ta"
                ],
                "type": "Dict.Dict Morphir.IR.FQName.FQName (Morphir.Scala.AST.Documented (Morphir.IR.Type.Definition ta))"
            }
        ],
        "values": [
            {
                "name": "enumExtensionName",
                "comment": " Extract the names out of an enum extension.\n",
                "type": "Morphir.Metadata.EnumExtensionComponent -> List.List Morphir.IR.Name.Name"
            },
            {
                "name": "getAliases",
                "comment": " Access function for getting the alias type registry from a Metadata structure.\n",
                "type": "Morphir.Metadata.Metadata ta -> Morphir.Metadata.Aliases"
            },
            {
                "name": "getBaseTypes",
                "comment": " Access function for getting the base type registry from a Metadata structure.\n",
                "type": "Morphir.Metadata.Metadata ta -> Morphir.Metadata.BaseTypes"
            },
            {
                "name": "getDocumentation",
                "comment": " Access function for getting the full type registry from a Metadata structure.\n",
                "type": "Morphir.Metadata.Metadata ta -> Morphir.IR.FQName.FQName -> Maybe.Maybe String.String"
            },
            {
                "name": "getEnums",
                "comment": " Access function for getting the enum registry from a Metadata structure.\n",
                "type": "Morphir.Metadata.Metadata ta -> Morphir.Metadata.Enums"
            },
            {
                "name": "getEnumsWithExtensions",
                "comment": " Access function for getting the enum registry from a Metadata structure that includes EnumExtensions.\n",
                "type": "Morphir.Metadata.Metadata ta -> Morphir.Metadata.Enums"
            },
            {
                "name": "getModules",
                "comment": " Access function for getting the module registry from a Metadata structure.\n",
                "type": "Morphir.Metadata.Metadata ta -> Morphir.Metadata.Modules"
            },
            {
                "name": "getTypes",
                "comment": " Access function for getting the type registry from a Metadata structure.\n",
                "type": "Morphir.Metadata.Metadata ta -> Morphir.Metadata.Types ta"
            },
            {
                "name": "getUnions",
                "comment": " Access function for getting the union type registry from a Metadata structure.\n",
                "type": "Morphir.Metadata.Metadata ta -> Morphir.Metadata.UnionTypes ta"
            },
            {
                "name": "isEnumExtension",
                "comment": " Decides whether a union type is an enum by ensuring it only has constructors with base type enum or no arg constructors.\n",
                "type": "Morphir.Metadata.Metadata a -> Morphir.IR.Type.Constructors a -> Basics.Bool"
            },
            {
                "name": "mapDistribution",
                "comment": " Process this distribution into a Metadata structure.\n",
                "type": "Morphir.IR.Distribution.Distribution -> Morphir.Metadata.Metadata ()"
            }
        ],
        "binops": []
    },
    {
        "name": "Morphir.SDK.Aggregate",
        "comment": " This module contains functions specifically designed to work with large data sets.\n\n\n# Aggregations\n\n@docs Aggregation\n@docs groupBy, aggregate\n@docs aggregateMap, aggregateMap2, aggregateMap3\n\n\n## Operators\n\n@docs count, sumOf, minimumOf, maximumOf, averageOf, weightedAverageOf\n@docs byKey, withFilter\n\n",
        "unions": [],
        "aliases": [
            {
                "name": "Aggregation",
                "comment": " Type that represents an aggregation on a type `a` with a key of `key`. It encapsulates the following information:\n\n  - `key` is a function that gets the key of each `a`\n  - `filter` is a function used for filtering items out before the aggregation. This can be set to `always True` to not do any filtering.\n  - `operator` is the aggregation operation to apply (count, sum, average, ...)\n\n",
                "args": [
                    "a",
                    "key"
                ],
                "type": "{ key : a -> key, filter : a -> Basics.Bool, operator : Morphir.SDK.Aggregate.Operator a }"
            }
        ],
        "values": [
            {
                "name": "aggregate",
                "comment": " Aggregates a dictionary that contains lists of items as values into a list that contains exactly one item per key.\nThe first argument is a function that takes a key and an aggregator and it should return a single item in the resulting\nlist. The aggregator is a function that takes one of the aggregation functions in this module (`count`, `sumOf`,\n`minimumOf`, ...) and returns the aggregated value for the list of values in the input dictionary.\n\n    grouped =\n        Dict.fromList\n            [ ( \"k1_1\"\n              , [ TestInput1 \"k1_1\" \"k2_1\" 1\n                , TestInput1 \"k1_1\" \"k2_1\" 2\n                , TestInput1 \"k1_1\" \"k2_2\" 3\n                , TestInput1 \"k1_1\" \"k2_2\" 4\n                ]\n            , ( \"k1_2\",\n              , [ TestInput1 \"k1_2\" \"k2_1\" 5\n                , TestInput1 \"k1_2\" \"k2_1\" 6\n                , TestInput1 \"k1_2\" \"k2_2\" 7\n                , TestInput1 \"k1_2\" \"k2_2\" 8\n                ]\n            ]\n\n    grouped\n        |> aggregate\n            (\\key inputs ->\n                { key = key\n                , count = inputs (count |> withFilter (\\a -> a.value < 7))\n                , sum = inputs (sumOf .value)\n                , max = inputs (maximumOf .value)\n                , min = inputs (minimumOf .value)\n                }\n            )\n            {- ==\n                [ { key = \"k1_1\", count = 4, sum = 10, max = 4, min = 1 }\n                , { key = \"k1_2\", count = 2, sum = 26, max = 8, min = 5 }\n                ]\n            -}\n\nThis function is designed to be used in combination with `groupBy`.\n\n    testDataSet =\n            [ TestInput1 \"k1_1\" \"k2_1\" 1\n            , TestInput1 \"k1_1\" \"k2_1\" 2\n            , TestInput1 \"k1_1\" \"k2_2\" 3\n            , TestInput1 \"k1_1\" \"k2_2\" 4\n            , TestInput1 \"k1_2\" \"k2_1\" 5\n            , TestInput1 \"k1_2\" \"k2_1\" 6\n            , TestInput1 \"k1_2\" \"k2_2\" 7\n            , TestInput1 \"k1_2\" \"k2_2\" 8\n            ]\n\n        testDataSet\n            |> groupBy .key1\n            |> aggregate\n                (\\key inputs ->\n                    { key = key\n                    , count = inputs (count |> withFilter (\\a -> a.value < 7))\n                    , sum = inputs (sumOf .value)\n                    , max = inputs (maximumOf .value)\n                    , min = inputs (minimumOf .value)\n                    }\n                )\n                { ==\n                    [ { key = \"k1_1\", count = 4, sum = 10, max = 4, min = 1 }\n                    , { key = \"k1_2\", count = 2, sum = 26, max = 8, min = 5 }\n                    ]\n                }\n\n",
                "type": "(key -> Morphir.SDK.Aggregate.Aggregator a Morphir.SDK.Key.Key0 -> b) -> AssocList.Dict key (List.List a) -> List.List b"
            },
            {
                "name": "aggregateMap",
                "comment": " Map function that provides an aggregated value to the mapping function. The first argument is a tuple where the\nfirst element is a function that defines the aggregation key, the second element is predicate that allows you to filter\nout certain rows from the aggregation and the third argument is the aggregation operation to apply. Usage:\n\n        testDataSet =\n            [ TestInput1 \"k1_1\" \"k2_1\" 1\n            , TestInput1 \"k1_1\" \"k2_1\" 2\n            , TestInput1 \"k1_1\" \"k2_2\" 3\n            , TestInput1 \"k1_1\" \"k2_2\" 4\n            , TestInput1 \"k1_2\" \"k2_1\" 5\n            , TestInput1 \"k1_2\" \"k2_1\" 6\n            , TestInput1 \"k1_2\" \"k2_2\" 7\n            , TestInput1 \"k1_2\" \"k2_2\" 8\n            ]\n\n        testDataSet\n            |> aggregateMap\n                (sumOf .value |> byKey .key1)\n                    (\\\\totalValue input ->\n                        ( input, totalValue / input.value )\n                    )\n            {- ==\n                [ ( TestInput1 \"k1_1\" \"k2_1\" 1, 10 / 1 )\n                , ( TestInput1 \"k1_1\" \"k2_1\" 2, 10 / 2 )\n                , ( TestInput1 \"k1_1\" \"k2_2\" 3, 10 / 3 )\n                , ( TestInput1 \"k1_1\" \"k2_2\" 4, 10 / 4 )\n                , ( TestInput1 \"k1_2\" \"k2_1\" 5, 26 / 5 )\n                , ( TestInput1 \"k1_2\" \"k2_1\" 6, 26 / 6 )\n                , ( TestInput1 \"k1_2\" \"k2_2\" 7, 26 / 7 )\n                , ( TestInput1 \"k1_2\" \"k2_2\" 8, 26 / 8 )\n                ]\n            -}\n\n",
                "type": "Morphir.SDK.Aggregate.Aggregation a key1 -> (Basics.Float -> a -> b) -> List.List a -> List.List b"
            },
            {
                "name": "aggregateMap2",
                "comment": " Map function that provides two aggregated values to the mapping function. The first argument is a tuple where the\nfirst element is a function that defines the aggregation key, the second element is predicate that allows you to filter\nout certain rows from the aggregation and the third argument is the aggregation operation to apply. Usage:\n\n        testDataSet =\n            [ TestInput1 \"k1_1\" \"k2_1\" 1\n            , TestInput1 \"k1_1\" \"k2_1\" 2\n            , TestInput1 \"k1_1\" \"k2_2\" 3\n            , TestInput1 \"k1_1\" \"k2_2\" 4\n            , TestInput1 \"k1_2\" \"k2_1\" 5\n            , TestInput1 \"k1_2\" \"k2_1\" 6\n            , TestInput1 \"k1_2\" \"k2_2\" 7\n            , TestInput1 \"k1_2\" \"k2_2\" 8\n            ]\n\n        testDataSet\n            |> aggregateMap2\n                (sumOf .value |> byKey .key1)\n                (maximumOf .value |> byKey .key2)\n                (\\totalValue maxValue input ->\n                    ( input, totalValue * maxValue / input.value )\n                )\n            {- ==\n                [ ( TestInput1 \"k1_1\" \"k2_1\" 1, 10 * 6 / 1 )\n                , ( TestInput1 \"k1_1\" \"k2_1\" 2, 10 * 6 / 2 )\n                , ( TestInput1 \"k1_1\" \"k2_2\" 3, 10 * 8 / 3 )\n                , ( TestInput1 \"k1_1\" \"k2_2\" 4, 10 * 8 / 4 )\n                , ( TestInput1 \"k1_2\" \"k2_1\" 5, 26 * 6 / 5 )\n                , ( TestInput1 \"k1_2\" \"k2_1\" 6, 26 * 6 / 6 )\n                , ( TestInput1 \"k1_2\" \"k2_2\" 7, 26 * 8 / 7 )\n                , ( TestInput1 \"k1_2\" \"k2_2\" 8, 26 * 8 / 8 )\n                ]\n            -}\n\n",
                "type": "Morphir.SDK.Aggregate.Aggregation a key1 -> Morphir.SDK.Aggregate.Aggregation a key2 -> (Basics.Float -> Basics.Float -> a -> b) -> List.List a -> List.List b"
            },
            {
                "name": "aggregateMap3",
                "comment": " Map function that provides three aggregated values to the mapping function. The first argument is a tuple where the\nfirst element is a function that defines the aggregation key, the second element is predicate that allows you to filter\nout certain rows from the aggregation and the third argument is the aggregation operation to apply. Usage:\n\n        testDataSet =\n            [ TestInput1 \"k1_1\" \"k2_1\" 1\n            , TestInput1 \"k1_1\" \"k2_1\" 2\n            , TestInput1 \"k1_1\" \"k2_2\" 3\n            , TestInput1 \"k1_1\" \"k2_2\" 4\n            , TestInput1 \"k1_2\" \"k2_1\" 5\n            , TestInput1 \"k1_2\" \"k2_1\" 6\n            , TestInput1 \"k1_2\" \"k2_2\" 7\n            , TestInput1 \"k1_2\" \"k2_2\" 8\n            ]\n\n        testDataSet\n            |> aggregateMap3\n                (sumOf .value |> byKey .key1)\n                (maximumOf .value |> byKey .key2)\n                (minimumOf .value |> byKey (key2 .key1 .key2))\n                (\\totalValue maxValue minValue input ->\n                    ( input, totalValue * maxValue / input.value + minValue )\n                )\n            {- ==\n                [ ( TestInput1 \"k1_1\" \"k2_1\" 1, 10 * 6 / 1 + 1 )\n                , ( TestInput1 \"k1_1\" \"k2_1\" 2, 10 * 6 / 2 + 1 )\n                , ( TestInput1 \"k1_1\" \"k2_2\" 3, 10 * 8 / 3 + 3 )\n                , ( TestInput1 \"k1_1\" \"k2_2\" 4, 10 * 8 / 4 + 3 )\n                , ( TestInput1 \"k1_2\" \"k2_1\" 5, 26 * 6 / 5 + 5 )\n                , ( TestInput1 \"k1_2\" \"k2_1\" 6, 26 * 6 / 6 + 5 )\n                , ( TestInput1 \"k1_2\" \"k2_2\" 7, 26 * 8 / 7 + 7 )\n                , ( TestInput1 \"k1_2\" \"k2_2\" 8, 26 * 8 / 8 + 7 )\n                ]\n            -}\n\n",
                "type": "Morphir.SDK.Aggregate.Aggregation a key1 -> Morphir.SDK.Aggregate.Aggregation a key2 -> Morphir.SDK.Aggregate.Aggregation a key3 -> (Basics.Float -> Basics.Float -> Basics.Float -> a -> b) -> List.List a -> List.List b"
            },
            {
                "name": "averageOf",
                "comment": " Apply a function to each row that returns a numeric value and return the average of the values.\n",
                "type": "(a -> Basics.Float) -> Morphir.SDK.Aggregate.Aggregation a Morphir.SDK.Key.Key0"
            },
            {
                "name": "byKey",
                "comment": " Changes the key of an aggregation. Usage:\n\n    count\n        |> byKey .key1\n        == { key = .key1\n           , filter = always True\n           , operator = Count\n           }\n\n",
                "type": "(a -> key) -> Morphir.SDK.Aggregate.Aggregation a Morphir.SDK.Key.Key0 -> Morphir.SDK.Aggregate.Aggregation a key"
            },
            {
                "name": "count",
                "comment": " Count the number of rows in a group.\n",
                "type": "Morphir.SDK.Aggregate.Aggregation a Morphir.SDK.Key.Key0"
            },
            {
                "name": "groupBy",
                "comment": " Group a list of items into a dictionary. Grouping is done using a function that returns a key for each item.\nThe resulting dictionary will use those keys as the key of each entry in the dictionary and values will be lists of\nitems for each key.\n\n    testDataSet =\n        [ TestInput1 \"k1_1\" \"k2_1\" 1\n        , TestInput1 \"k1_1\" \"k2_1\" 2\n        , TestInput1 \"k1_1\" \"k2_2\" 3\n        , TestInput1 \"k1_1\" \"k2_2\" 4\n        , TestInput1 \"k1_2\" \"k2_1\" 5\n        , TestInput1 \"k1_2\" \"k2_1\" 6\n        , TestInput1 \"k1_2\" \"k2_2\" 7\n        , TestInput1 \"k1_2\" \"k2_2\" 8\n        ]\n\n    testDataSet\n        |> groupBy .key1\n            {- == Dict.fromList\n                        [ ( \"k1_1\"\n                          , [ TestInput1 \"k1_1\" \"k2_1\" 1\n                            , TestInput1 \"k1_1\" \"k2_1\" 2\n                            , TestInput1 \"k1_1\" \"k2_2\" 3\n                            , TestInput1 \"k1_1\" \"k2_2\" 4\n                            ]\n                        , ( \"k1_2\",\n                          , [ TestInput1 \"k1_2\" \"k2_1\" 5\n                            , TestInput1 \"k1_2\" \"k2_1\" 6\n                            , TestInput1 \"k1_2\" \"k2_2\" 7\n                            , TestInput1 \"k1_2\" \"k2_2\" 8\n                            ]\n                        ]\n            -}\n\n",
                "type": "(a -> key) -> List.List a -> AssocList.Dict key (List.List a)"
            },
            {
                "name": "maximumOf",
                "comment": " Apply a function to each row that returns a numeric value and return the maximum of the values.\n",
                "type": "(a -> Basics.Float) -> Morphir.SDK.Aggregate.Aggregation a Morphir.SDK.Key.Key0"
            },
            {
                "name": "minimumOf",
                "comment": " Apply a function to each row that returns a numeric value and return the minimum of the values.\n",
                "type": "(a -> Basics.Float) -> Morphir.SDK.Aggregate.Aggregation a Morphir.SDK.Key.Key0"
            },
            {
                "name": "sumOf",
                "comment": " Apply a function to each row that returns a numeric value and return the sum of the values.\n",
                "type": "(a -> Basics.Float) -> Morphir.SDK.Aggregate.Aggregation a Morphir.SDK.Key.Key0"
            },
            {
                "name": "weightedAverageOf",
                "comment": " Apply two functions to each row that returns a numeric value and return the weighted of the values using the first\nfunction to get the weights.\n",
                "type": "(a -> Basics.Float) -> (a -> Basics.Float) -> Morphir.SDK.Aggregate.Aggregation a Morphir.SDK.Key.Key0"
            },
            {
                "name": "withFilter",
                "comment": " Adds a filter to an aggregation. Usage:\n\n    count\n        |> withFilter (\\a -> a.value < 0)\n        == { key = key0\n           , filter = \\a -> a.value < 0\n           , operator = Count\n           }\n\n",
                "type": "(a -> Basics.Bool) -> Morphir.SDK.Aggregate.Aggregation a key -> Morphir.SDK.Aggregate.Aggregation a key"
            }
        ],
        "binops": []
    },
    {
        "name": "Morphir.SDK.Decimal",
        "comment": "\n\n\n# The datatype\n\n@docs Decimal\n\n\n# Convert from\n\n@docs fromInt\n@docs fromFloat\n@docs fromString\n\n\n# Convert from known exponent\n\n@docs hundred\n@docs thousand\n@docs million\n@docs tenth\n@docs hundredth\n@docs thousandth\n@docs millionth\n@docs bps\n\n\n# Convert to\n\n@docs toString\n\n\n# Arithmetic operations\n\n@docs add\n@docs sub\n@docs negate\n@docs mul\n@docs div\n@docs divWithDefault\n\n\n# Rounding\n\n@docs truncate\n@docs round\n\n\n# Comparing\n\n@docs gt\n@docs gte\n@docs eq\n@docs neq\n@docs lt\n@docs lte\n@docs compare\n\n\n# Misc operations\n\n@docs abs, shiftDecimalLeft, shiftDecimalRight\n\n\n# Common Constants\n\n@docs zero\n@docs one\n@docs minusOne\n\n",
        "unions": [],
        "aliases": [
            {
                "name": "Decimal",
                "comment": " The Decimal data type\n",
                "args": [],
                "type": "Decimal.Decimal"
            }
        ],
        "values": [
            {
                "name": "abs",
                "comment": " Absolute value (sets the sign as positive)\n",
                "type": "Morphir.SDK.Decimal.Decimal -> Morphir.SDK.Decimal.Decimal"
            },
            {
                "name": "add",
                "comment": " Addition\n",
                "type": "Morphir.SDK.Decimal.Decimal -> Morphir.SDK.Decimal.Decimal -> Morphir.SDK.Decimal.Decimal"
            },
            {
                "name": "bps",
                "comment": " Converts an Int to a Decimal that represents n basis points (i.e. 1/10 of % or a ten-thousandth\n",
                "type": "Basics.Int -> Morphir.SDK.Decimal.Decimal"
            },
            {
                "name": "compare",
                "comment": " Compares two Decimals\n",
                "type": "Morphir.SDK.Decimal.Decimal -> Morphir.SDK.Decimal.Decimal -> Basics.Order"
            },
            {
                "name": "div",
                "comment": " Divide two decimals\n",
                "type": "Morphir.SDK.Decimal.Decimal -> Morphir.SDK.Decimal.Decimal -> Maybe.Maybe Morphir.SDK.Decimal.Decimal"
            },
            {
                "name": "divWithDefault",
                "comment": " Divide two decimals providing a default for the cases the calculation fails, such as divide by zero or overflow/underflow.\n",
                "type": "Morphir.SDK.Decimal.Decimal -> Morphir.SDK.Decimal.Decimal -> Morphir.SDK.Decimal.Decimal -> Morphir.SDK.Decimal.Decimal"
            },
            {
                "name": "eq",
                "comment": " Equals\n",
                "type": "Morphir.SDK.Decimal.Decimal -> Morphir.SDK.Decimal.Decimal -> Basics.Bool"
            },
            {
                "name": "fromFloat",
                "comment": " Converts a Float to a Decimal\n",
                "type": "Basics.Float -> Morphir.SDK.Decimal.Decimal"
            },
            {
                "name": "fromInt",
                "comment": " Converts an Int to a Decimal\n",
                "type": "Basics.Int -> Morphir.SDK.Decimal.Decimal"
            },
            {
                "name": "fromString",
                "comment": " Converts a String to a Maybe Decimal. The string shall be in the format [<sign>]<numbers>[.<numbers>][e<numbers>]\n",
                "type": "String.String -> Maybe.Maybe Morphir.SDK.Decimal.Decimal"
            },
            {
                "name": "gt",
                "comment": " Greater than\n",
                "type": "Morphir.SDK.Decimal.Decimal -> Morphir.SDK.Decimal.Decimal -> Basics.Bool"
            },
            {
                "name": "gte",
                "comment": " Greater than or equals\n",
                "type": "Morphir.SDK.Decimal.Decimal -> Morphir.SDK.Decimal.Decimal -> Basics.Bool"
            },
            {
                "name": "hundred",
                "comment": " Converts an Int to a Decimal that represents n hundreds.\n",
                "type": "Basics.Int -> Morphir.SDK.Decimal.Decimal"
            },
            {
                "name": "hundredth",
                "comment": " Converts an Int to a Decimal that represents n hundredths.\n",
                "type": "Basics.Int -> Morphir.SDK.Decimal.Decimal"
            },
            {
                "name": "lt",
                "comment": " Less than\n",
                "type": "Morphir.SDK.Decimal.Decimal -> Morphir.SDK.Decimal.Decimal -> Basics.Bool"
            },
            {
                "name": "lte",
                "comment": " Less than or equals\n",
                "type": "Morphir.SDK.Decimal.Decimal -> Morphir.SDK.Decimal.Decimal -> Basics.Bool"
            },
            {
                "name": "million",
                "comment": " Converts an Int to a Decimal that represents n millions.\n",
                "type": "Basics.Int -> Morphir.SDK.Decimal.Decimal"
            },
            {
                "name": "millionth",
                "comment": " Converts an Int to a Decimal that represents n millionth.\n",
                "type": "Basics.Int -> Morphir.SDK.Decimal.Decimal"
            },
            {
                "name": "minusOne",
                "comment": " The number -1\n",
                "type": "Morphir.SDK.Decimal.Decimal"
            },
            {
                "name": "mul",
                "comment": " Multiplication\n",
                "type": "Morphir.SDK.Decimal.Decimal -> Morphir.SDK.Decimal.Decimal -> Morphir.SDK.Decimal.Decimal"
            },
            {
                "name": "negate",
                "comment": " Changes the sign of a Decimal\n",
                "type": "Morphir.SDK.Decimal.Decimal -> Morphir.SDK.Decimal.Decimal"
            },
            {
                "name": "neq",
                "comment": " Not equals\n",
                "type": "Morphir.SDK.Decimal.Decimal -> Morphir.SDK.Decimal.Decimal -> Basics.Bool"
            },
            {
                "name": "one",
                "comment": " The number 1\n",
                "type": "Morphir.SDK.Decimal.Decimal"
            },
            {
                "name": "round",
                "comment": " `round` to the nearest integer.\n",
                "type": "Morphir.SDK.Decimal.Decimal -> Morphir.SDK.Decimal.Decimal"
            },
            {
                "name": "shiftDecimalLeft",
                "comment": " Shift the decimal n digits to the left.\n",
                "type": "Basics.Int -> Morphir.SDK.Decimal.Decimal -> Morphir.SDK.Decimal.Decimal"
            },
            {
                "name": "shiftDecimalRight",
                "comment": " Shift the decimal n digits to the right.\n",
                "type": "Basics.Int -> Morphir.SDK.Decimal.Decimal -> Morphir.SDK.Decimal.Decimal"
            },
            {
                "name": "sub",
                "comment": " Subtraction\n",
                "type": "Morphir.SDK.Decimal.Decimal -> Morphir.SDK.Decimal.Decimal -> Morphir.SDK.Decimal.Decimal"
            },
            {
                "name": "tenth",
                "comment": " Converts an Int to a Decimal that represents n tenths.\n",
                "type": "Basics.Int -> Morphir.SDK.Decimal.Decimal"
            },
            {
                "name": "thousand",
                "comment": " Converts an Int to a Decimal that represents n thousands\n",
                "type": "Basics.Int -> Morphir.SDK.Decimal.Decimal"
            },
            {
                "name": "thousandth",
                "comment": " Converts an Int to a Decimal that represents n thousandths.\n",
                "type": "Basics.Int -> Morphir.SDK.Decimal.Decimal"
            },
            {
                "name": "toString",
                "comment": " Converts a Decimal to a String\n",
                "type": "Morphir.SDK.Decimal.Decimal -> String.String"
            },
            {
                "name": "truncate",
                "comment": " Truncates the Decimal to the nearest integer with `TowardsZero` mode\n",
                "type": "Morphir.SDK.Decimal.Decimal -> Morphir.SDK.Decimal.Decimal"
            },
            {
                "name": "zero",
                "comment": " The number 0\n",
                "type": "Morphir.SDK.Decimal.Decimal"
            }
        ],
        "binops": []
    },
    {
        "name": "Morphir.SDK.Dict",
        "comment": " A dictionary mapping unique keys to values. The keys can be any comparable\ntype. This includes `Int`, `Float`, `Time`, `Char`, `String`, and tuples or\nlists of comparable types.\n\nInsert, remove, and query operations all take _O(log n)_ time.\n\n\n# Dictionaries\n\n@docs Dict\n\n\n# Build\n\n@docs empty, singleton, insert, update, remove\n\n\n# Query\n\n@docs isEmpty, member, get, size\n\n\n# Lists\n\n@docs keys, values, toList, fromList\n\n\n# Transform\n\n@docs map, foldl, foldr, filter, partition\n\n\n# Combine\n\n@docs union, intersect, diff, merge\n\n",
        "unions": [],
        "aliases": [
            {
                "name": "Dict",
                "comment": " A dictionary of keys and values. So a `Dict String User` is a dictionary\nthat lets you look up a `String` (such as user names) and find the associated\n`User`.\n\n    import Dict exposing (Dict)\n\n    users : Dict String User\n    users =\n        Dict.fromList\n            [ ( \"Alice\", User \"Alice\" 28 1.65 )\n            , ( \"Bob\", User \"Bob\" 19 1.82 )\n            , ( \"Chuck\", User \"Chuck\" 33 1.75 )\n            ]\n\n    type alias User =\n        { name : String\n        , age : Int\n        , height : Float\n        }\n\n",
                "args": [
                    "k",
                    "v"
                ],
                "type": "AssocList.Dict k v"
            }
        ],
        "values": [
            {
                "name": "diff",
                "comment": " Keep a key-value pair when its key does not appear in the second dictionary.\n",
                "type": "Morphir.SDK.Dict.Dict comp a -> Morphir.SDK.Dict.Dict comp b -> Morphir.SDK.Dict.Dict comp a"
            },
            {
                "name": "empty",
                "comment": " Create an empty dictionary.\n",
                "type": "Morphir.SDK.Dict.Dict k v"
            },
            {
                "name": "filter",
                "comment": " Keep only the key-value pairs that pass the given test.\n",
                "type": "(comp -> v -> Basics.Bool) -> Morphir.SDK.Dict.Dict comp v -> Morphir.SDK.Dict.Dict comp v"
            },
            {
                "name": "foldl",
                "comment": " Fold over the key-value pairs in a dictionary from lowest key to highest key.\n\n    import Dict exposing (Dict)\n\n    getAges : Dict String User -> List String\n    getAges users =\n        Dict.foldl addAge [] users\n\n    addAge : String -> User -> List String -> List String\n    addAge _ user ages =\n        user.age :: ages\n\n    -- getAges users == [33,19,28]\n\n",
                "type": "(k -> v -> b -> b) -> b -> Morphir.SDK.Dict.Dict k v -> b"
            },
            {
                "name": "foldr",
                "comment": " Fold over the key-value pairs in a dictionary from highest key to lowest key.\n\n    import Dict exposing (Dict)\n\n    getAges : Dict String User -> List String\n    getAges users =\n        Dict.foldr addAge [] users\n\n    addAge : String -> User -> List String -> List String\n    addAge _ user ages =\n        user.age :: ages\n\n    -- getAges users == [28,19,33]\n\n",
                "type": "(k -> v -> b -> b) -> b -> Morphir.SDK.Dict.Dict k v -> b"
            },
            {
                "name": "fromList",
                "comment": " Convert an association list into a dictionary.\n",
                "type": "List.List ( comp, v ) -> Morphir.SDK.Dict.Dict comp v"
            },
            {
                "name": "get",
                "comment": " Get the value associated with a key. If the key is not found, return\n`Nothing`. This is useful when you are not sure if a key will be in the\ndictionary.\n\n    animals = fromList [ (\"Tom\", Cat), (\"Jerry\", Mouse) ]\n\n    get \"Tom\"   animals == Just Cat\n    get \"Jerry\" animals == Just Mouse\n    get \"Spike\" animals == Nothing\n\n",
                "type": "comp -> Morphir.SDK.Dict.Dict comp v -> Maybe.Maybe v"
            },
            {
                "name": "insert",
                "comment": " Insert a key-value pair into a dictionary. Replaces value when there is\na collision.\n",
                "type": "comp -> v -> Morphir.SDK.Dict.Dict comp v -> Morphir.SDK.Dict.Dict comp v"
            },
            {
                "name": "intersect",
                "comment": " Keep a key-value pair when its key appears in the second dictionary.\nPreference is given to values in the first dictionary.\n",
                "type": "Morphir.SDK.Dict.Dict comp v -> Morphir.SDK.Dict.Dict comp v -> Morphir.SDK.Dict.Dict comp v"
            },
            {
                "name": "isEmpty",
                "comment": " Determine if a dictionary is empty.\n\n    isEmpty empty == True\n\n",
                "type": "Morphir.SDK.Dict.Dict k v -> Basics.Bool"
            },
            {
                "name": "keys",
                "comment": " Get all of the keys in a dictionary, sorted from lowest to highest.\n\n    keys (fromList [ ( 0, \"Alice\" ), ( 1, \"Bob\" ) ]) == [ 0, 1 ]\n\n",
                "type": "Morphir.SDK.Dict.Dict k v -> List.List k"
            },
            {
                "name": "map",
                "comment": " Apply a function to all values in a dictionary.\n",
                "type": "(k -> a -> b) -> Morphir.SDK.Dict.Dict k a -> Morphir.SDK.Dict.Dict k b"
            },
            {
                "name": "member",
                "comment": " Determine if a key is in a dictionary.\n",
                "type": "comp -> Morphir.SDK.Dict.Dict comp v -> Basics.Bool"
            },
            {
                "name": "merge",
                "comment": " The most general way of combining two dictionaries. You provide three\naccumulators for when a given key appears:\n\n1.  Only in the left dictionary.\n2.  In both dictionaries.\n3.  Only in the right dictionary.\n\nYou then traverse all the keys from lowest to highest, building up whatever\nyou want.\n\n",
                "type": "(comp -> a -> result -> result) -> (comp -> a -> b -> result -> result) -> (comp -> b -> result -> result) -> Morphir.SDK.Dict.Dict comp a -> Morphir.SDK.Dict.Dict comp b -> result -> result"
            },
            {
                "name": "partition",
                "comment": " Partition a dictionary according to some test. The first dictionary\ncontains all key-value pairs which passed the test, and the second contains\nthe pairs that did not.\n",
                "type": "(comp -> v -> Basics.Bool) -> Morphir.SDK.Dict.Dict comp v -> ( Morphir.SDK.Dict.Dict comp v, Morphir.SDK.Dict.Dict comp v )"
            },
            {
                "name": "remove",
                "comment": " Remove a key-value pair from a dictionary. If the key is not found,\nno changes are made.\n",
                "type": "comp -> Morphir.SDK.Dict.Dict comp v -> Morphir.SDK.Dict.Dict comp v"
            },
            {
                "name": "singleton",
                "comment": " Create a dictionary with one key-value pair.\n",
                "type": "comp -> v -> Morphir.SDK.Dict.Dict comp v"
            },
            {
                "name": "size",
                "comment": " Determine the number of key-value pairs in the dictionary.\n",
                "type": "Morphir.SDK.Dict.Dict k v -> Basics.Int"
            },
            {
                "name": "toList",
                "comment": " Convert a dictionary into an association list of key-value pairs, sorted by keys.\n",
                "type": "Morphir.SDK.Dict.Dict k v -> List.List ( k, v )"
            },
            {
                "name": "union",
                "comment": " Combine two dictionaries. If there is a collision, preference is given\nto the first dictionary.\n",
                "type": "Morphir.SDK.Dict.Dict comp v -> Morphir.SDK.Dict.Dict comp v -> Morphir.SDK.Dict.Dict comp v"
            },
            {
                "name": "update",
                "comment": " Update the value of a dictionary for a specific key with a given function.\n",
                "type": "comp -> (Maybe.Maybe v -> Maybe.Maybe v) -> Morphir.SDK.Dict.Dict comp v -> Morphir.SDK.Dict.Dict comp v"
            },
            {
                "name": "values",
                "comment": " Get all of the values in a dictionary, in the order of their keys.\n\n    values (fromList [ ( 0, \"Alice\" ), ( 1, \"Bob\" ) ]) == [ \"Alice\", \"Bob\" ]\n\n",
                "type": "Morphir.SDK.Dict.Dict k v -> List.List v"
            }
        ],
        "binops": []
    },
    {
        "name": "Morphir.SDK.Int",
        "comment": " This module adds some support for fixed precision integers. We intentionally limit the operations that you can do\non fixed precision integers because in general it's difficult to decide whether a calculation will result in an overflow\nin the general case. At the same time having the ability to encode fixed precision integers in your domain model can be\nvery useful. This module allows you to do that while making sure that you can only use arbitrary precision integers\nin your calculation.\n\nExample use:\n\n    calc : Int8 -> Int16 -> Int8\n    calc a b =\n        let\n            arbA =\n                Int.fromInt8 a\n\n            abrB =\n                Int.fromInt16 b\n        in\n        arbA\n            * arbB\n            |> Int.toInt8\n            |> Maybe.withDefault 0\n\nThe above example shows how the user is required to either provide a default value or change the return type of the\nfunction to handle cases where the calculation might return a value that doesn't fit in the 8 bit precision.\n\n@docs Int8, fromInt8, toInt8\n@docs Int16, fromInt16, toInt16\n@docs Int32, fromInt32, toInt32\n@docs Int64, fromInt64, toInt64\n\n",
        "unions": [
            {
                "name": "Int16",
                "comment": " Represents a 16 bit integer value.\n",
                "args": [],
                "cases": []
            },
            {
                "name": "Int32",
                "comment": " Represents a 32 bit integer value.\n",
                "args": [],
                "cases": []
            },
            {
                "name": "Int64",
                "comment": " Represents a 64 bit integer value.\n",
                "args": [],
                "cases": []
            },
            {
                "name": "Int8",
                "comment": " Represents an 8 bit integer value.\n",
                "args": [],
                "cases": []
            }
        ],
        "aliases": [],
        "values": [
            {
                "name": "fromInt16",
                "comment": " Turn an 16 bit integer value into an arbitrary precision integer to use in calculations.\n",
                "type": "Morphir.SDK.Int.Int16 -> Basics.Int"
            },
            {
                "name": "fromInt32",
                "comment": " Turn an 32 bit integer value into an arbitrary precision integer to use in calculations.\n",
                "type": "Morphir.SDK.Int.Int32 -> Basics.Int"
            },
            {
                "name": "fromInt64",
                "comment": " Turn an 64 bit integer value into an arbitrary precision integer to use in calculations.\n",
                "type": "Morphir.SDK.Int.Int64 -> Basics.Int"
            },
            {
                "name": "fromInt8",
                "comment": " Turn an 8 bit integer value into an arbitrary precision integer to use in calculations.\n",
                "type": "Morphir.SDK.Int.Int8 -> Basics.Int"
            },
            {
                "name": "toInt16",
                "comment": " Turn an arbitrary precision integer into an 16 bit integer if it fits within the precision.\n",
                "type": "Basics.Int -> Maybe.Maybe Morphir.SDK.Int.Int16"
            },
            {
                "name": "toInt32",
                "comment": " Turn an arbitrary precision integer into an 32 bit integer if it fits within the precision.\n",
                "type": "Basics.Int -> Maybe.Maybe Morphir.SDK.Int.Int32"
            },
            {
                "name": "toInt64",
                "comment": " Turn an arbitrary precision integer into an 64 bit integer if it fits within the precision.\n",
                "type": "Basics.Int -> Maybe.Maybe Morphir.SDK.Int.Int64"
            },
            {
                "name": "toInt8",
                "comment": " Turn an arbitrary precision integer into an 8 bit integer if it fits within the precision.\n",
                "type": "Basics.Int -> Maybe.Maybe Morphir.SDK.Int.Int8"
            }
        ],
        "binops": []
    },
    {
        "name": "Morphir.SDK.Key",
        "comment": " Helpers to work with composite keys.\n\n\n# Motivation\n\nIt is difficult to work with composite keys in Elm due to various limitations:\n\n  - Keys should be comparable. Record and union types are not comparable in Elm. We can only use Tuples to represent them.\n  - Tuples are limited at 3 elements. Real-world composite keys can easily have more elements than that.\n  - Unit is not comparable. This makes it impossible to pass in a zero element key where comparable keys are required.\n\nThis library resolves those issues by introducing type aliases for keys of various element sizes. All these types are\ngeneric to let developers to create their custom types to be comparable and they all have utility functions to compose them. Here's an example:\n\n    type alias MyEntity =\n        { foo : String\n        , bar : Int\n        , baz : Float\n        }\n\n    -- myKey : Key3 Int String Float\n    myKey =\n        key3 .bar .foo .baz\n\n**Note:** This file was generated using Elm code that is included as a comment at the end of the source code for this\nmodule. You can use that code to extend this module without too much manual work.\n\n\n# Composing Keys\n\n@docs noKey, key0, key2, key3, key4, key5, key6, key7, key8, key9, key10, key11, key12, key13, key14, key15, key16\n\n\n# Key Types\n\n@docs Key0, Key2, Key3, Key4, Key5, Key6, Key7, Key8, Key9, Key10, Key11, Key12, Key13, Key14, Key15, Key16\n\n",
        "unions": [],
        "aliases": [
            {
                "name": "Key0",
                "comment": " Type that represents a zero element key. The ideal representation would be `()` but `Unit` is not comparable in Elm.\nSo we use `Int` to retain comparable semantics but only `0` should be used as a value.\n`key0` and `noKey` can be used to create a `Key0` value.\n",
                "args": [],
                "type": "Basics.Int"
            },
            {
                "name": "Key10",
                "comment": " Type that represents a composite key with 10 elements.\n",
                "args": [
                    "k1",
                    "k2",
                    "k3",
                    "k4",
                    "k5",
                    "k6",
                    "k7",
                    "k8",
                    "k9",
                    "k10"
                ],
                "type": "( k1, k2, ( k3, k4, ( k5, k6, ( k7, k8, ( k9, k10 ) ) ) ) )"
            },
            {
                "name": "Key11",
                "comment": " Type that represents a composite key with 11 elements.\n",
                "args": [
                    "k1",
                    "k2",
                    "k3",
                    "k4",
                    "k5",
                    "k6",
                    "k7",
                    "k8",
                    "k9",
                    "k10",
                    "k11"
                ],
                "type": "( k1, k2, ( k3, k4, ( k5, k6, ( k7, k8, ( k9, k10, k11 ) ) ) ) )"
            },
            {
                "name": "Key12",
                "comment": " Type that represents a composite key with 12 elements.\n",
                "args": [
                    "k1",
                    "k2",
                    "k3",
                    "k4",
                    "k5",
                    "k6",
                    "k7",
                    "k8",
                    "k9",
                    "k10",
                    "k11",
                    "k12"
                ],
                "type": "( k1, k2, ( k3, k4, ( k5, k6, ( k7, k8, ( k9, k10, ( k11, k12 ) ) ) ) ) )"
            },
            {
                "name": "Key13",
                "comment": " Type that represents a composite key with 13 elements.\n",
                "args": [
                    "k1",
                    "k2",
                    "k3",
                    "k4",
                    "k5",
                    "k6",
                    "k7",
                    "k8",
                    "k9",
                    "k10",
                    "k11",
                    "k12",
                    "k13"
                ],
                "type": "( k1, k2, ( k3, k4, ( k5, k6, ( k7, k8, ( k9, k10, ( k11, k12, k13 ) ) ) ) ) )"
            },
            {
                "name": "Key14",
                "comment": " Type that represents a composite key with 14 elements.\n",
                "args": [
                    "k1",
                    "k2",
                    "k3",
                    "k4",
                    "k5",
                    "k6",
                    "k7",
                    "k8",
                    "k9",
                    "k10",
                    "k11",
                    "k12",
                    "k13",
                    "k14"
                ],
                "type": "( k1, k2, ( k3, k4, ( k5, k6, ( k7, k8, ( k9, k10, ( k11, k12, ( k13, k14 ) ) ) ) ) ) )"
            },
            {
                "name": "Key15",
                "comment": " Type that represents a composite key with 15 elements.\n",
                "args": [
                    "k1",
                    "k2",
                    "k3",
                    "k4",
                    "k5",
                    "k6",
                    "k7",
                    "k8",
                    "k9",
                    "k10",
                    "k11",
                    "k12",
                    "k13",
                    "k14",
                    "k15"
                ],
                "type": "( k1, k2, ( k3, k4, ( k5, k6, ( k7, k8, ( k9, k10, ( k11, k12, ( k13, k14, k15 ) ) ) ) ) ) )"
            },
            {
                "name": "Key16",
                "comment": " Type that represents a composite key with 16 elements.\n",
                "args": [
                    "k1",
                    "k2",
                    "k3",
                    "k4",
                    "k5",
                    "k6",
                    "k7",
                    "k8",
                    "k9",
                    "k10",
                    "k11",
                    "k12",
                    "k13",
                    "k14",
                    "k15",
                    "k16"
                ],
                "type": "( k1, k2, ( k3, k4, ( k5, k6, ( k7, k8, ( k9, k10, ( k11, k12, ( k13, k14, ( k15, k16 ) ) ) ) ) ) ) )"
            },
            {
                "name": "Key2",
                "comment": " Type that represents a composite key with 2 elements.\n",
                "args": [
                    "k1",
                    "k2"
                ],
                "type": "( k1, k2 )"
            },
            {
                "name": "Key3",
                "comment": " Type that represents a composite key with 3 elements.\n",
                "args": [
                    "k1",
                    "k2",
                    "k3"
                ],
                "type": "( k1, k2, k3 )"
            },
            {
                "name": "Key4",
                "comment": " Type that represents a composite key with 4 elements.\n",
                "args": [
                    "k1",
                    "k2",
                    "k3",
                    "k4"
                ],
                "type": "( k1, k2, ( k3, k4 ) )"
            },
            {
                "name": "Key5",
                "comment": " Type that represents a composite key with 5 elements.\n",
                "args": [
                    "k1",
                    "k2",
                    "k3",
                    "k4",
                    "k5"
                ],
                "type": "( k1, k2, ( k3, k4, k5 ) )"
            },
            {
                "name": "Key6",
                "comment": " Type that represents a composite key with 6 elements.\n",
                "args": [
                    "k1",
                    "k2",
                    "k3",
                    "k4",
                    "k5",
                    "k6"
                ],
                "type": "( k1, k2, ( k3, k4, ( k5, k6 ) ) )"
            },
            {
                "name": "Key7",
                "comment": " Type that represents a composite key with 7 elements.\n",
                "args": [
                    "k1",
                    "k2",
                    "k3",
                    "k4",
                    "k5",
                    "k6",
                    "k7"
                ],
                "type": "( k1, k2, ( k3, k4, ( k5, k6, k7 ) ) )"
            },
            {
                "name": "Key8",
                "comment": " Type that represents a composite key with 8 elements.\n",
                "args": [
                    "k1",
                    "k2",
                    "k3",
                    "k4",
                    "k5",
                    "k6",
                    "k7",
                    "k8"
                ],
                "type": "( k1, k2, ( k3, k4, ( k5, k6, ( k7, k8 ) ) ) )"
            },
            {
                "name": "Key9",
                "comment": " Type that represents a composite key with 9 elements.\n",
                "args": [
                    "k1",
                    "k2",
                    "k3",
                    "k4",
                    "k5",
                    "k6",
                    "k7",
                    "k8",
                    "k9"
                ],
                "type": "( k1, k2, ( k3, k4, ( k5, k6, ( k7, k8, k9 ) ) ) )"
            }
        ],
        "values": [
            {
                "name": "key0",
                "comment": " Creates a key with zero elements.\n",
                "type": "a -> Morphir.SDK.Key.Key0"
            },
            {
                "name": "key10",
                "comment": " Create a composite key with 10 elements.\n",
                "type": "(a -> b1) -> (a -> b2) -> (a -> b3) -> (a -> b4) -> (a -> b5) -> (a -> b6) -> (a -> b7) -> (a -> b8) -> (a -> b9) -> (a -> b10) -> a -> Morphir.SDK.Key.Key10 b1 b2 b3 b4 b5 b6 b7 b8 b9 b10"
            },
            {
                "name": "key11",
                "comment": " Create a composite key with 11 elements.\n",
                "type": "(a -> b1) -> (a -> b2) -> (a -> b3) -> (a -> b4) -> (a -> b5) -> (a -> b6) -> (a -> b7) -> (a -> b8) -> (a -> b9) -> (a -> b10) -> (a -> b11) -> a -> Morphir.SDK.Key.Key11 b1 b2 b3 b4 b5 b6 b7 b8 b9 b10 b11"
            },
            {
                "name": "key12",
                "comment": " Create a composite key with 12 elements.\n",
                "type": "(a -> b1) -> (a -> b2) -> (a -> b3) -> (a -> b4) -> (a -> b5) -> (a -> b6) -> (a -> b7) -> (a -> b8) -> (a -> b9) -> (a -> b10) -> (a -> b11) -> (a -> b12) -> a -> Morphir.SDK.Key.Key12 b1 b2 b3 b4 b5 b6 b7 b8 b9 b10 b11 b12"
            },
            {
                "name": "key13",
                "comment": " Create a composite key with 13 elements.\n",
                "type": "(a -> b1) -> (a -> b2) -> (a -> b3) -> (a -> b4) -> (a -> b5) -> (a -> b6) -> (a -> b7) -> (a -> b8) -> (a -> b9) -> (a -> b10) -> (a -> b11) -> (a -> b12) -> (a -> b13) -> a -> Morphir.SDK.Key.Key13 b1 b2 b3 b4 b5 b6 b7 b8 b9 b10 b11 b12 b13"
            },
            {
                "name": "key14",
                "comment": " Create a composite key with 14 elements.\n",
                "type": "(a -> b1) -> (a -> b2) -> (a -> b3) -> (a -> b4) -> (a -> b5) -> (a -> b6) -> (a -> b7) -> (a -> b8) -> (a -> b9) -> (a -> b10) -> (a -> b11) -> (a -> b12) -> (a -> b13) -> (a -> b14) -> a -> Morphir.SDK.Key.Key14 b1 b2 b3 b4 b5 b6 b7 b8 b9 b10 b11 b12 b13 b14"
            },
            {
                "name": "key15",
                "comment": " Create a composite key with 15 elements.\n",
                "type": "(a -> b1) -> (a -> b2) -> (a -> b3) -> (a -> b4) -> (a -> b5) -> (a -> b6) -> (a -> b7) -> (a -> b8) -> (a -> b9) -> (a -> b10) -> (a -> b11) -> (a -> b12) -> (a -> b13) -> (a -> b14) -> (a -> b15) -> a -> Morphir.SDK.Key.Key15 b1 b2 b3 b4 b5 b6 b7 b8 b9 b10 b11 b12 b13 b14 b15"
            },
            {
                "name": "key16",
                "comment": " Create a composite key with 16 elements.\n",
                "type": "(a -> b1) -> (a -> b2) -> (a -> b3) -> (a -> b4) -> (a -> b5) -> (a -> b6) -> (a -> b7) -> (a -> b8) -> (a -> b9) -> (a -> b10) -> (a -> b11) -> (a -> b12) -> (a -> b13) -> (a -> b14) -> (a -> b15) -> (a -> b16) -> a -> Morphir.SDK.Key.Key16 b1 b2 b3 b4 b5 b6 b7 b8 b9 b10 b11 b12 b13 b14 b15 b16"
            },
            {
                "name": "key2",
                "comment": " Create a composite key with 2 elements.\n",
                "type": "(a -> b1) -> (a -> b2) -> a -> Morphir.SDK.Key.Key2 b1 b2"
            },
            {
                "name": "key3",
                "comment": " Create a composite key with 3 elements.\n",
                "type": "(a -> b1) -> (a -> b2) -> (a -> b3) -> a -> Morphir.SDK.Key.Key3 b1 b2 b3"
            },
            {
                "name": "key4",
                "comment": " Create a composite key with 4 elements.\n",
                "type": "(a -> b1) -> (a -> b2) -> (a -> b3) -> (a -> b4) -> a -> Morphir.SDK.Key.Key4 b1 b2 b3 b4"
            },
            {
                "name": "key5",
                "comment": " Create a composite key with 5 elements.\n",
                "type": "(a -> b1) -> (a -> b2) -> (a -> b3) -> (a -> b4) -> (a -> b5) -> a -> Morphir.SDK.Key.Key5 b1 b2 b3 b4 b5"
            },
            {
                "name": "key6",
                "comment": " Create a composite key with 6 elements.\n",
                "type": "(a -> b1) -> (a -> b2) -> (a -> b3) -> (a -> b4) -> (a -> b5) -> (a -> b6) -> a -> Morphir.SDK.Key.Key6 b1 b2 b3 b4 b5 b6"
            },
            {
                "name": "key7",
                "comment": " Create a composite key with 7 elements.\n",
                "type": "(a -> b1) -> (a -> b2) -> (a -> b3) -> (a -> b4) -> (a -> b5) -> (a -> b6) -> (a -> b7) -> a -> Morphir.SDK.Key.Key7 b1 b2 b3 b4 b5 b6 b7"
            },
            {
                "name": "key8",
                "comment": " Create a composite key with 8 elements.\n",
                "type": "(a -> b1) -> (a -> b2) -> (a -> b3) -> (a -> b4) -> (a -> b5) -> (a -> b6) -> (a -> b7) -> (a -> b8) -> a -> Morphir.SDK.Key.Key8 b1 b2 b3 b4 b5 b6 b7 b8"
            },
            {
                "name": "key9",
                "comment": " Create a composite key with 9 elements.\n",
                "type": "(a -> b1) -> (a -> b2) -> (a -> b3) -> (a -> b4) -> (a -> b5) -> (a -> b6) -> (a -> b7) -> (a -> b8) -> (a -> b9) -> a -> Morphir.SDK.Key.Key9 b1 b2 b3 b4 b5 b6 b7 b8 b9"
            },
            {
                "name": "noKey",
                "comment": " Creates a key with zero elements.\n",
                "type": "a -> Morphir.SDK.Key.Key0"
            }
        ],
        "binops": []
    },
    {
        "name": "Morphir.SDK.List",
        "comment": " Extra utilities on lists.\n\n@docs innerJoin, leftJoin, rightJoin\n\n",
        "unions": [],
        "aliases": [],
        "values": [
            {
                "name": "innerJoin",
                "comment": " Simulates a SQL inner-join.\n\n    dataSetA =\n        [ ( 1, \"a\" ), ( 2, \"b\" ) ]\n\n    dataSetB =\n        [ ( 3, \"C\" ), ( 2, \"B\" ) ]\n\n    dataSetA\n        |> innerJoin dataSetB\n            (\\a b ->\n               Tuple.first a == Tuple.first b\n            ) ==\n            [ ( ( 2, \"b\" ), ( 2, \"B\" ) )\n            ]\n\n",
                "type": "List.List b -> (a -> b -> Basics.Bool) -> List.List a -> List.List ( a, b )"
            },
            {
                "name": "leftJoin",
                "comment": " Simulates a SQL left-outer-join.\n\n    dataSetA =\n        [ ( 1, \"a\" ), ( 2, \"b\" ) ]\n\n    dataSetB =\n        [ ( 3, \"C\" ), ( 2, \"B\" ) ]\n\n    dataSetA\n        |> leftJoin dataSetB\n            (\\a b ->\n               Tuple.first a == Tuple.first b\n            ) ==\n            [ ( ( 1, \"a\" ), Nothing )\n            , ( ( 2, \"b\" ), Just ( 2, \"B\" ) )\n            ]\n\n",
                "type": "List.List b -> (a -> b -> Basics.Bool) -> List.List a -> List.List ( a, Maybe.Maybe b )"
            },
            {
                "name": "rightJoin",
                "comment": " Simulates a SQL right-outer-join.\n\n    dataSetA =\n        [ ( 1, \"a\" ), ( 2, \"b\" ) ]\n\n    dataSetB =\n        [ ( 3, \"C\" ), ( 2, \"B\" ) ]\n\n    dataSetA\n        |> rightJoin dataSetB\n            (\\a b ->\n               Tuple.first a == Tuple.first b\n            ) ==\n            [ ( Just ( 2, \"b\" ), ( 2, \"B\" ) )\n            , ( Nothing, ( 3, \"C\" ) )\n            ]\n\n",
                "type": "List.List b -> (a -> b -> Basics.Bool) -> List.List a -> List.List ( Maybe.Maybe a, b )"
            }
        ],
        "binops": []
    },
    {
        "name": "Morphir.SDK.LocalDate",
        "comment": " This module adds the definition of a date without time zones. Useful in business modeling.\n\n\n# Types\n\n@docs LocalDate\n\n\n# Date Math\n\n@docs diffInDays, diffInWeeks, diffInMonths, diffInYears\n@docs addDays, addWeeks, addMonths, addYears\n\n\n# Constructors\n\n@docs fromISO, fromParts\n\n",
        "unions": [],
        "aliases": [
            {
                "name": "LocalDate",
                "comment": " Concept of a date without time zones.\n",
                "args": [],
                "type": "Date.Date"
            }
        ],
        "values": [
            {
                "name": "addDays",
                "comment": " Add the given days to a given date.\n",
                "type": "Basics.Int -> Morphir.SDK.LocalDate.LocalDate -> Morphir.SDK.LocalDate.LocalDate"
            },
            {
                "name": "addMonths",
                "comment": " Add the given months to a given date.\n",
                "type": "Basics.Int -> Morphir.SDK.LocalDate.LocalDate -> Morphir.SDK.LocalDate.LocalDate"
            },
            {
                "name": "addWeeks",
                "comment": " Add the given weeks to a given date.\n",
                "type": "Basics.Int -> Morphir.SDK.LocalDate.LocalDate -> Morphir.SDK.LocalDate.LocalDate"
            },
            {
                "name": "addYears",
                "comment": " Add the given years to a given date.\n",
                "type": "Basics.Int -> Morphir.SDK.LocalDate.LocalDate -> Morphir.SDK.LocalDate.LocalDate"
            },
            {
                "name": "diffInDays",
                "comment": " Find the number of days between the given dates.\n",
                "type": "Morphir.SDK.LocalDate.LocalDate -> Morphir.SDK.LocalDate.LocalDate -> Basics.Int"
            },
            {
                "name": "diffInMonths",
                "comment": " Find the number of months between the given dates.\n",
                "type": "Morphir.SDK.LocalDate.LocalDate -> Morphir.SDK.LocalDate.LocalDate -> Basics.Int"
            },
            {
                "name": "diffInWeeks",
                "comment": " Find the number of weeks between the given dates.\n",
                "type": "Morphir.SDK.LocalDate.LocalDate -> Morphir.SDK.LocalDate.LocalDate -> Basics.Int"
            },
            {
                "name": "diffInYears",
                "comment": " Find the number of years between the given dates.\n",
                "type": "Morphir.SDK.LocalDate.LocalDate -> Morphir.SDK.LocalDate.LocalDate -> Basics.Int"
            },
            {
                "name": "fromISO",
                "comment": " Construct a LocalDate based on ISO formatted string. Opportunity for error denoted by Maybe return type.\n",
                "type": "String.String -> Maybe.Maybe Morphir.SDK.LocalDate.LocalDate"
            },
            {
                "name": "fromParts",
                "comment": " Construct a LocalDate based on Year, Month, Day. Opportunity for error denoted by Maybe return type.\nErrors can occur when any of the given values fall outside of their relevant constraints.\nFor example, the date given as 2000 2 30 (2000-Feb-30) would fail because the day of the 30th is impossible.\n",
                "type": "Basics.Int -> Basics.Int -> Basics.Int -> Maybe.Maybe Morphir.SDK.LocalDate.LocalDate"
            }
        ],
        "binops": []
    },
    {
        "name": "Morphir.SDK.LocalTime",
        "comment": " This module adds the definition of basic time without time zones.\n\n\n# Types\n\n@docs LocalTime\n\n\n# Time Math\n\n@docs addHours\n@docs addMinutes\n@docs addSeconds\n@docs diffInHours\n@docs diffInMinutes\n@docs diffInSeconds\n\n\n\n# Constructors\n\n@docs fromISO\n@docs fromMilliseconds\n",
        "unions": [],
        "aliases": [
            {
                "name": "LocalTime",
                "comment": " Concept of time without time zones.\n",
                "args": [],
                "type": "Time.Posix"
            }
        ],
        "values": [
            {
                "name": "addHours",
                "comment": " Add the given hours to a given time\n",
                "type": "Basics.Int -> Morphir.SDK.LocalTime.LocalTime -> Morphir.SDK.LocalTime.LocalTime"
            },
            {
                "name": "addMinutes",
                "comment": " Add the given minutes to a given time.\n",
                "type": "Basics.Int -> Morphir.SDK.LocalTime.LocalTime -> Morphir.SDK.LocalTime.LocalTime"
            },
            {
                "name": "addSeconds",
                "comment": " Add the given seconds to a given time.\n",
                "type": "Basics.Int -> Morphir.SDK.LocalTime.LocalTime -> Morphir.SDK.LocalTime.LocalTime"
            },
            {
                "name": "diffInHours",
                "comment": " Find the difference of give times in hours\n",
                "type": "Morphir.SDK.LocalTime.LocalTime -> Morphir.SDK.LocalTime.LocalTime -> Basics.Int"
            },
            {
                "name": "diffInMinutes",
                "comment": " Find the difference of give times in minutes\n",
                "type": "Morphir.SDK.LocalTime.LocalTime -> Morphir.SDK.LocalTime.LocalTime -> Basics.Int"
            },
            {
                "name": "diffInSeconds",
                "comment": " Find the difference of give times in minutes\n",
                "type": "Morphir.SDK.LocalTime.LocalTime -> Morphir.SDK.LocalTime.LocalTime -> Basics.Int"
            },
            {
                "name": "fromISO",
                "comment": " Construct a LocalTime based on ISO formatted string. Opportunity for error denoted by Maybe return type.\n",
                "type": "String.String -> Maybe.Maybe Morphir.SDK.LocalTime.LocalTime"
            },
            {
                "name": "fromMilliseconds",
                "comment": " Construct a LocalTime based on number of milliseconds from epoch. Opportunity for error denoted by Maybe return type.\n",
                "type": "Basics.Int -> Morphir.SDK.LocalTime.LocalTime"
            }
        ],
        "binops": []
    },
    {
        "name": "Morphir.SDK.Month",
        "comment": " This module adds the definition of a month concept for business modeling.\n@docs Month\n",
        "unions": [
            {
                "name": "Month",
                "comment": " Gregorian calendar months in English.\n",
                "args": [],
                "cases": []
            }
        ],
        "aliases": [],
        "values": [],
        "binops": []
    },
    {
        "name": "Morphir.SDK.Number",
        "comment": " This module provides a way to represent a number without the risk of rounding issues or division by zero for any of\nthe basic operations: `+`, `-`, `*`, `/`. More accurately a `Number` represents an arbitrary-precision rational number.\nIf you need irrational numbers please use a `Float`.\n\n@docs Number\n\n\n# Convert from\n\n@docs fromInt\n\n\n# Comparison\n\n@docs equal, notEqual, lessThan, lessThanOrEqual, greaterThan, greaterThanOrEqual\n\n\n# Arithmetic\n\n@docs add, subtract, multiply, divide, abs, negate, reciprocal\n\n\n# Convert to\n\n@docs toFractionalString, toDecimal, coerceToDecimal\n\n\n# Misc\n\n@docs simplify, isSimplified\n\n\n# Constants\n\n@docs zero, one\n\n",
        "unions": [
            {
                "name": "Number",
                "comment": " Represents an arbitrary-precision rational number.\n",
                "args": [],
                "cases": [
                    [
                        "Rational",
                        [
                            "BigInt.BigInt",
                            "BigInt.BigInt"
                        ]
                    ]
                ]
            }
        ],
        "aliases": [],
        "values": [
            {
                "name": "abs",
                "comment": " Takes the absolute value of the number\n",
                "type": "Morphir.SDK.Number.Number -> Morphir.SDK.Number.Number"
            },
            {
                "name": "add",
                "comment": " Adds two numbers together.\n",
                "type": "Morphir.SDK.Number.Number -> Morphir.SDK.Number.Number -> Morphir.SDK.Number.Number"
            },
            {
                "name": "coerceToDecimal",
                "comment": " Turn a number into a decimal, by providing a default value in the case things go awry.\n",
                "type": "Morphir.SDK.Decimal.Decimal -> Morphir.SDK.Number.Number -> Morphir.SDK.Decimal.Decimal"
            },
            {
                "name": "divide",
                "comment": " Division\n",
                "type": "Morphir.SDK.Number.Number -> Morphir.SDK.Number.Number -> Result.Result Morphir.SDK.Number.DivisionByZero Morphir.SDK.Number.Number"
            },
            {
                "name": "equal",
                "comment": " Checks if two numbers are equal.\n\n    equal one one == True\n\n    equal one (divide ten ten) == True\n\n    equal one zero == False\n\n",
                "type": "Morphir.SDK.Number.Number -> Morphir.SDK.Number.Number -> Basics.Bool"
            },
            {
                "name": "fromInt",
                "comment": " Create a Number by converting it from an Int\n",
                "type": "Basics.Int -> Morphir.SDK.Number.Number"
            },
            {
                "name": "greaterThan",
                "comment": " Checks if the first number is greater than the second\n",
                "type": "Morphir.SDK.Number.Number -> Morphir.SDK.Number.Number -> Basics.Bool"
            },
            {
                "name": "greaterThanOrEqual",
                "comment": " Checks if the first number is greater or equal than the second\n",
                "type": "Morphir.SDK.Number.Number -> Morphir.SDK.Number.Number -> Basics.Bool"
            },
            {
                "name": "isSimplified",
                "comment": " Tells if the number is simplified\n",
                "type": "Morphir.SDK.Number.Number -> Basics.Bool"
            },
            {
                "name": "lessThan",
                "comment": " Checks if the first number is less than the second\n",
                "type": "Morphir.SDK.Number.Number -> Morphir.SDK.Number.Number -> Basics.Bool"
            },
            {
                "name": "lessThanOrEqual",
                "comment": " Checks if the first number is less than or equal to the second\n",
                "type": "Morphir.SDK.Number.Number -> Morphir.SDK.Number.Number -> Basics.Bool"
            },
            {
                "name": "multiply",
                "comment": " Multiplies two numbers together\n",
                "type": "Morphir.SDK.Number.Number -> Morphir.SDK.Number.Number -> Morphir.SDK.Number.Number"
            },
            {
                "name": "negate",
                "comment": " Negate the given number, thus flipping the sign.\n",
                "type": "Morphir.SDK.Number.Number -> Morphir.SDK.Number.Number"
            },
            {
                "name": "notEqual",
                "comment": " Checks if two numbers are not equal.\n\n    notEqual one zero == True\n\n    notEqual zero one == True\n\n    notEqual one one == False\n\n",
                "type": "Morphir.SDK.Number.Number -> Morphir.SDK.Number.Number -> Basics.Bool"
            },
            {
                "name": "one",
                "comment": " Constant for one\n",
                "type": "Morphir.SDK.Number.Number"
            },
            {
                "name": "reciprocal",
                "comment": " Calculates the reciprocal of the number\n",
                "type": "Morphir.SDK.Number.Number -> Morphir.SDK.Number.Number"
            },
            {
                "name": "simplify",
                "comment": " Tries to simplify the number.\n",
                "type": "Morphir.SDK.Number.Number -> Maybe.Maybe Morphir.SDK.Number.Number"
            },
            {
                "name": "subtract",
                "comment": " Subtracts one number from the other.\n",
                "type": "Morphir.SDK.Number.Number -> Morphir.SDK.Number.Number -> Morphir.SDK.Number.Number"
            },
            {
                "name": "toDecimal",
                "comment": " Turn a number into a decimal.\nNOTE: it is possible for this operation to fail if the Number is a rational number for 0.\n",
                "type": "Morphir.SDK.Number.Number -> Maybe.Maybe Morphir.SDK.Decimal.Decimal"
            },
            {
                "name": "toFractionalString",
                "comment": " Create a fractional representation of the number\n",
                "type": "Morphir.SDK.Number.Number -> String.String"
            },
            {
                "name": "zero",
                "comment": " Constant for 0\n",
                "type": "Morphir.SDK.Number.Number"
            }
        ],
        "binops": []
    },
    {
        "name": "Morphir.SDK.ResultList",
        "comment": " This module contains operations that are specific to lists of results. These operations are very useful for modeling\nprocessing pipelines where errors could happen at any point in the pipeline but they should not break the processing\nitself.\n\n@docs ResultList\n\n\n# Creating\n\n@docs fromList\n\n\n# Processing\n\n@docs filter, filterOrFail, map, mapOrFail\n\n\n# Decomposing\n\n@docs errors, successes, partition\n\n\n# Mapping to single result\n\n@docs keepAllErrors, keepFirstError\n\n",
        "unions": [],
        "aliases": [
            {
                "name": "ResultList",
                "comment": " Type that represents a list that contains a mix of failed and successful records.\n",
                "args": [
                    "e",
                    "a"
                ],
                "type": "List.List (Result.Result e a)"
            }
        ],
        "values": [
            {
                "name": "errors",
                "comment": " Extract all errors from the result list.\n\n    errors [ Ok 1, Ok 2, Ok 3, Ok 4 ] == []\n\n    errors [ Ok 1, Err \"foo\", Ok 3, Err \"bar\" ] == [ Err \"foo\", Err \"bar\" ]\n\n    errors [ Err \"foo\", Err \"bar\" ] == [ Err \"foo\", Err \"bar\" ]\n\n",
                "type": "Morphir.SDK.ResultList.ResultList e a -> List.List e"
            },
            {
                "name": "filter",
                "comment": " Filter a result list retaining all previously failed items.\n\n    filter isOdd [ Ok 1, Ok 2, Ok 3 ] == [ Ok 1, Ok 3 ]\n\n    filter isOdd [ Err \"foo\", Ok 2, Ok 3 ] == [ Err \"foo\", Ok 3 ]\n\n",
                "type": "(a -> Basics.Bool) -> Morphir.SDK.ResultList.ResultList e a -> Morphir.SDK.ResultList.ResultList e a"
            },
            {
                "name": "filterOrFail",
                "comment": " Filter a result list retaining all previously failed items.\n\n    divide a =\n        if a == 0 then\n            Err \"division by zero\"\n\n        else\n            isOdd a\n\n    filterOrFail divide [ Ok -1, Ok 0, Err \"earlier\", Ok 2 ] == [ Ok -1, Err \"division by zero\", Err \"earlier\" ]\n\n",
                "type": "(a -> Result.Result e Basics.Bool) -> Morphir.SDK.ResultList.ResultList e a -> Morphir.SDK.ResultList.ResultList e a"
            },
            {
                "name": "fromList",
                "comment": " Create a result list from any list.\n\n    fromList [ 1, 2, 3 ] == [ Ok 1, Ok 2, Ok 3 ]\n\n",
                "type": "List.List a -> Morphir.SDK.ResultList.ResultList e a"
            },
            {
                "name": "keepAllErrors",
                "comment": " Turn a list of results into a single result keeping all errors.\n",
                "type": "Morphir.SDK.ResultList.ResultList e a -> Result.Result (List.List e) (List.List a)"
            },
            {
                "name": "keepFirstError",
                "comment": " Turn a list of results into a single result keeping only the first error.\n",
                "type": "Morphir.SDK.ResultList.ResultList e a -> Result.Result e (List.List a)"
            },
            {
                "name": "map",
                "comment": " Map a result list retaining all previously failed items.\n\n    map double [ Ok 1, Ok 2, Ok 3 ] == [ Ok 2, Ok 4, Ok 6 ]\n\n    map isOdd [ Err \"foo\", Ok 2, Ok 3 ] == [ Err \"foo\", Ok 4, Ok 6 ]\n\n",
                "type": "(a -> b) -> Morphir.SDK.ResultList.ResultList e a -> Morphir.SDK.ResultList.ResultList e b"
            },
            {
                "name": "mapOrFail",
                "comment": " Map a result list retaining all previously failed items.\n\n    divide a =\n        if a == 0 then\n            Err \"division by zero\"\n\n        else\n            Ok (100 / a)\n\n    mapOrFail divide [ Ok -1, Ok 0, Err \"earlier\" ] == [ Ok -100, Err \"division by zero\", Err \"earlier\" ]\n\n",
                "type": "(a -> Result.Result e b) -> Morphir.SDK.ResultList.ResultList e a -> Morphir.SDK.ResultList.ResultList e b"
            },
            {
                "name": "partition",
                "comment": " Partition a result list into errors and successes.\n\n    partition [ Ok 1, Ok 2, Ok 3, Ok 4 ] == ( [], [ Ok 1, Ok 2, Ok 3, Ok 4 ] )\n\n    partition [ Ok 1, Err \"foo\", Ok 3, Err \"bar\" ] == ( [ Err \"foo\", Err \"bar\" ], [ Ok 1, Ok 3 ] )\n\n    partition [ Err \"foo\", Err \"bar\" ] == ( [ Err \"foo\", Err \"bar\" ], [] )\n\n",
                "type": "Morphir.SDK.ResultList.ResultList e a -> ( List.List e, List.List a )"
            },
            {
                "name": "successes",
                "comment": " Extract all successes from the result list.\n\n    successes [ Ok 1, Ok 2, Ok 3, Ok 4 ] == [ Ok 1, Ok 2, Ok 3, Ok 4 ]\n\n    successes [ Ok 1, Err \"foo\", Ok 3, Err \"bar\" ] == [ Ok 1, Ok 3 ]\n\n    successes [ Err \"foo\", Err \"bar\" ] == []\n\n",
                "type": "Morphir.SDK.ResultList.ResultList e a -> List.List a"
            }
        ],
        "binops": []
    },
    {
        "name": "Morphir.SDK.Rule",
        "comment": " This module supports defining business logic as a set of rules. You can think of it as a functional rules engine.\nThe logic is built up of rules that are composed into rule sets. In traditional rules engines these rule sets can be\nexecuted in a variety of ways that can yield different results. Morphir prefers predictability over flexibility so we\nonly support sequential execution. While this might sound limiting it greatly improves readability and enforces modelers\nto break up large rule sets into smaller targeted ones.\n\n@docs Rule\n\n@docs chain\n\n@docs any, is, anyOf, noneOf\n\n",
        "unions": [],
        "aliases": [
            {
                "name": "Rule",
                "comment": " Type that represents a single rule. A rule is a function that is only applicable on certain inputs. In other words\nit's a partial-function. Since Elm/Morphir only supports total functions it is represented as a function that returns\nan optional value. When the function is applicable it will return `Just b` otherwise `Nothing`.\n",
                "args": [
                    "a",
                    "b"
                ],
                "type": "a -> Maybe.Maybe b"
            }
        ],
        "values": [
            {
                "name": "any",
                "comment": " Simply returns true for any input. Use as a wildcard in a decision table.\n",
                "type": "a -> Basics.Bool"
            },
            {
                "name": "anyOf",
                "comment": " Returns `True` only if the second argument can be found in the list specified in the first argument. Use in a\ndecision table to match when a value is in a predefined set.\n",
                "type": "List.List a -> a -> Basics.Bool"
            },
            {
                "name": "chain",
                "comment": " Chain a list of rules into a single rule. Rules are evaluated sequentially in the order they were supplied and\nthe first rule that matches will be applied.\n\n    myChain =\n        chain\n            [ \\a -> Nothing -- A rule that never matches\n            , \\a -> Just a -- A rule that always matches and returns the original value\n            ]\n\n    myChain 42 == Just 42\n\n",
                "type": "List.List (Morphir.SDK.Rule.Rule a b) -> a -> Maybe.Maybe b"
            },
            {
                "name": "is",
                "comment": " Returns `True` only if the second argument is equal to the first. Use in a decision table for exact match.\n",
                "type": "a -> a -> Basics.Bool"
            },
            {
                "name": "noneOf",
                "comment": " Returns `True` only if the second argument cannot be found in the list specified in the first argument. Use in a\ndecision table to match when a value is not in a predefined set.\n",
                "type": "List.List a -> a -> Basics.Bool"
            }
        ],
        "binops": []
    },
    {
        "name": "Morphir.SDK.StatefulApp",
        "comment": " API for modeling stateful applications.\n\n@docs StatefulApp\n\n",
        "unions": [
            {
                "name": "StatefulApp",
                "comment": " Type that represents a stateful application. The following type parameters allow you to fit it to your use case:\n\n  - **k** - Key that's used to partition commands, events and state.\n  - **c** - Type that defines all the commands accepted by the application.\n  - **s** - Type that defines the state managed by the application.\n  - **e** - Type that defines all the events published by the application.\n\n",
                "args": [
                    "k",
                    "c",
                    "s",
                    "e"
                ],
                "cases": [
                    [
                        "StatefulApp",
                        [
                            "Maybe.Maybe s -> c -> ( Maybe.Maybe s, e )"
                        ]
                    ]
                ]
            }
        ],
        "aliases": [],
        "values": [],
        "binops": []
    },
    {
        "name": "Morphir.SDK.String",
        "comment": " Utilities to extends the basic String operations provided by `elm/core`.\n\n\n# Constraints\n\nConstraints provide a way to add value level constraints to types that are stored as Strings. While the Elm compiler\ndoesn't support checking such constraints statically we can use the information in Morphir backends to generate more\nspecific types. For example given the below definition:\n\n    type alias Trade =\n        { productID : Cusip\n        , comment : Maybe Comment\n        }\n\n    type Cusip\n        = Cusip String\n\n    cusip =\n        String.ofLength 9 Cusip\n\n    type Comment\n        = Comment String\n\n    comment =\n        String.ofMaxLength 100 Comment\n\nWe can generate the following DDL in our relational backend:\n\n```sql\nCREATE TABLE\n    trade\n    ( product_id CHAR 9 NOT NULL\n    , comment VARCHAR 100 NULL\n    )\n```\n\n@docs ofLength, ofMaxLength\n\n",
        "unions": [],
        "aliases": [],
        "values": [
            {
                "name": "ofLength",
                "comment": " Checks the exact length of a string and wraps it using the specified constructor.\n\n    currency =\n        String.ofLength 3 Currency\n\n    currency \"USD\" == Just (Currency \"USD\")\n    currency \"us\" == Nothing\n    currency \"LONG\" == Nothing\n\n",
                "type": "Basics.Int -> (String.String -> a) -> String.String -> Maybe.Maybe a"
            },
            {
                "name": "ofMaxLength",
                "comment": " Checks the max length of a string and wraps it using the specified constructor.\n\n    name =\n        String.ofMaxLength 15 Name\n\n    name \"\" == Just (Name \"\")\n    name \"A name\" == Just (Name \"\")\n    name \"A very long name\" == Nothing\n\n",
                "type": "Basics.Int -> (String.String -> a) -> String.String -> Maybe.Maybe a"
            }
        ],
        "binops": []
    },
    {
        "name": "Morphir.Scala.AST",
        "comment": " Scala's abstract-syntax tree. This is a custom built AST that focuses on the subset of Scala features that our\ngenerator uses. It's a relatively large portion of the language but it's not aiming to be complete.\n\n\n# Abstract Syntax Tree\n\n@docs Name, Path, Documented, Annotated, withAnnotation, withoutAnnotation, CompilationUnit, PackageDecl\n@docs ImportDecl, ImportName, Mod, TypeDecl, ArgDecl, ArgValue, MemberDecl\n@docs Type, Value, Pattern, Lit, Generator\n\n\n# Utilities\n\n@docs nameOfTypeDecl\n\n",
        "unions": [
            {
                "name": "ArgValue",
                "comment": " ",
                "args": [],
                "cases": [
                    [
                        "ArgValue",
                        [
                            "Maybe.Maybe Morphir.Scala.AST.Name",
                            "Morphir.Scala.AST.Value"
                        ]
                    ]
                ]
            },
            {
                "name": "Generator",
                "comment": " ",
                "args": [],
                "cases": [
                    [
                        "Extract",
                        [
                            "Morphir.Scala.AST.Pattern",
                            "Morphir.Scala.AST.Value"
                        ]
                    ],
                    [
                        "Bind",
                        [
                            "Morphir.Scala.AST.Pattern",
                            "Morphir.Scala.AST.Value"
                        ]
                    ],
                    [
                        "Guard",
                        [
                            "Morphir.Scala.AST.Value"
                        ]
                    ]
                ]
            },
            {
                "name": "ImportName",
                "comment": " ",
                "args": [],
                "cases": []
            },
            {
                "name": "Lit",
                "comment": " ",
                "args": [],
                "cases": [
                    [
                        "BooleanLit",
                        [
                            "Basics.Bool"
                        ]
                    ],
                    [
                        "CharacterLit",
                        [
                            "Char.Char"
                        ]
                    ],
                    [
                        "StringLit",
                        [
                            "String.String"
                        ]
                    ],
                    [
                        "IntegerLit",
                        [
                            "Basics.Int"
                        ]
                    ],
                    [
                        "FloatLit",
                        [
                            "Basics.Float"
                        ]
                    ],
                    [
                        "DecimalLit",
                        [
                            "Decimal.Decimal"
                        ]
                    ]
                ]
            },
            {
                "name": "MemberDecl",
                "comment": " ",
                "args": [],
                "cases": [
                    [
                        "TypeAlias",
                        [
                            "{ alias : Morphir.Scala.AST.Name, typeArgs : List.List Morphir.Scala.AST.Type, tpe : Morphir.Scala.AST.Type }"
                        ]
                    ],
                    [
                        "ValueDecl",
                        [
                            "{ modifiers : List.List Morphir.Scala.AST.Mod, pattern : Morphir.Scala.AST.Pattern, valueType : Maybe.Maybe Morphir.Scala.AST.Type, value : Morphir.Scala.AST.Value }"
                        ]
                    ],
                    [
                        "FunctionDecl",
                        [
                            "{ modifiers : List.List Morphir.Scala.AST.Mod, name : Morphir.Scala.AST.Name, typeArgs : List.List Morphir.Scala.AST.Type, args : List.List (List.List Morphir.Scala.AST.ArgDecl), returnType : Maybe.Maybe Morphir.Scala.AST.Type, body : Maybe.Maybe Morphir.Scala.AST.Value }"
                        ]
                    ],
                    [
                        "MemberTypeDecl",
                        [
                            "Morphir.Scala.AST.TypeDecl"
                        ]
                    ]
                ]
            },
            {
                "name": "Mod",
                "comment": " ",
                "args": [],
                "cases": [
                    [
                        "Sealed",
                        []
                    ],
                    [
                        "Final",
                        []
                    ],
                    [
                        "Case",
                        []
                    ],
                    [
                        "Val",
                        []
                    ],
                    [
                        "Package",
                        []
                    ],
                    [
                        "Implicit",
                        []
                    ],
                    [
                        "Private",
                        [
                            "Maybe.Maybe String.String"
                        ]
                    ],
                    [
                        "Abstract",
                        []
                    ]
                ]
            },
            {
                "name": "Pattern",
                "comment": " ",
                "args": [],
                "cases": [
                    [
                        "WildcardMatch",
                        []
                    ],
                    [
                        "NamedMatch",
                        [
                            "Morphir.Scala.AST.Name"
                        ]
                    ],
                    [
                        "AliasedMatch",
                        [
                            "Morphir.Scala.AST.Name",
                            "Morphir.Scala.AST.Pattern"
                        ]
                    ],
                    [
                        "LiteralMatch",
                        [
                            "Morphir.Scala.AST.Lit"
                        ]
                    ],
                    [
                        "UnapplyMatch",
                        [
                            "Morphir.Scala.AST.Path",
                            "Morphir.Scala.AST.Name",
                            "List.List Morphir.Scala.AST.Pattern"
                        ]
                    ],
                    [
                        "TupleMatch",
                        [
                            "List.List Morphir.Scala.AST.Pattern"
                        ]
                    ],
                    [
                        "EmptyListMatch",
                        []
                    ],
                    [
                        "HeadTailMatch",
                        [
                            "Morphir.Scala.AST.Pattern",
                            "Morphir.Scala.AST.Pattern"
                        ]
                    ],
                    [
                        "CommentedPattern",
                        [
                            "Morphir.Scala.AST.Pattern",
                            "String.String"
                        ]
                    ]
                ]
            },
            {
                "name": "Type",
                "comment": " ",
                "args": [],
                "cases": [
                    [
                        "TypeVar",
                        [
                            "Morphir.Scala.AST.Name"
                        ]
                    ],
                    [
                        "TypeRef",
                        [
                            "Morphir.Scala.AST.Path",
                            "Morphir.Scala.AST.Name"
                        ]
                    ],
                    [
                        "TypeApply",
                        [
                            "Morphir.Scala.AST.Type",
                            "List.List Morphir.Scala.AST.Type"
                        ]
                    ],
                    [
                        "TypeParametrized",
                        [
                            "Morphir.Scala.AST.Type",
                            "List.List Morphir.Scala.AST.Type",
                            "Morphir.Scala.AST.Type"
                        ]
                    ],
                    [
                        "TupleType",
                        [
                            "List.List Morphir.Scala.AST.Type"
                        ]
                    ],
                    [
                        "StructuralType",
                        [
                            "List.List Morphir.Scala.AST.MemberDecl"
                        ]
                    ],
                    [
                        "FunctionType",
                        [
                            "Morphir.Scala.AST.Type",
                            "Morphir.Scala.AST.Type"
                        ]
                    ],
                    [
                        "CommentedType",
                        [
                            "Morphir.Scala.AST.Type",
                            "String.String"
                        ]
                    ]
                ]
            },
            {
                "name": "TypeDecl",
                "comment": " ",
                "args": [],
                "cases": [
                    [
                        "Trait",
                        [
                            "{ modifiers : List.List Morphir.Scala.AST.Mod, name : Morphir.Scala.AST.Name, typeArgs : List.List Morphir.Scala.AST.Type, extends : List.List Morphir.Scala.AST.Type, members : List.List (Morphir.Scala.AST.Annotated Morphir.Scala.AST.MemberDecl) }"
                        ]
                    ],
                    [
                        "Class",
                        [
                            "{ modifiers : List.List Morphir.Scala.AST.Mod, name : Morphir.Scala.AST.Name, typeArgs : List.List Morphir.Scala.AST.Type, ctorArgs : List.List (List.List Morphir.Scala.AST.ArgDecl), extends : List.List Morphir.Scala.AST.Type, members : List.List (Morphir.Scala.AST.Annotated Morphir.Scala.AST.MemberDecl) }"
                        ]
                    ],
                    [
                        "Object",
                        [
                            "{ modifiers : List.List Morphir.Scala.AST.Mod, name : Morphir.Scala.AST.Name, extends : List.List Morphir.Scala.AST.Type, members : List.List (Morphir.Scala.AST.Annotated Morphir.Scala.AST.MemberDecl), body : Maybe.Maybe Morphir.Scala.AST.Value }"
                        ]
                    ]
                ]
            },
            {
                "name": "Value",
                "comment": " Type that represents a Scala Value.\n\nThese are the supported Values:\n\n  - **Literal**\n      - Specifies a Scala literal\n  - **Variable**\n      - Specifies a Scala variable\n  - **Ref**\n      - Represents a Scala function reference\n  - **Select**\n      - Represents an operation with a target expression and a name, where the name is applied with a '.' to the target.\n      - For example, '..obj.mymethod(param1, param2)' where 'mymethod' is the name and '..obj' is the target expression.\n      - Any argument list needed, such as '(param1, param2)', is appended to the Select value.\n  - **Wildcard**\n  - **Apply**\n      - Apply a Scala function\n  - **UnOp**\n  - **BinOp**\n      - Scala binary operation\n  - **Lambda**\n  - **Block**\n  - **MatchCases**\n  - **Match**\n  - **IfElse**\n  - **Tuple**\n  - **StructuralValue**\n  - **Unit**\n      - Return type of a Scala function which doesn't return anything\n      - Unit is represented as '{}'\n  - **This**\n  - **CommentedValue**\n  - **ForComp**\n\n",
                "args": [],
                "cases": [
                    [
                        "Literal",
                        [
                            "Morphir.Scala.AST.Lit"
                        ]
                    ],
                    [
                        "Variable",
                        [
                            "Morphir.Scala.AST.Name"
                        ]
                    ],
                    [
                        "Ref",
                        [
                            "Morphir.Scala.AST.Path",
                            "Morphir.Scala.AST.Name"
                        ]
                    ],
                    [
                        "Select",
                        [
                            "Morphir.Scala.AST.Value",
                            "Morphir.Scala.AST.Name"
                        ]
                    ],
                    [
                        "Wildcard",
                        []
                    ],
                    [
                        "Apply",
                        [
                            "Morphir.Scala.AST.Value",
                            "List.List Morphir.Scala.AST.ArgValue"
                        ]
                    ],
                    [
                        "UnOp",
                        [
                            "String.String",
                            "Morphir.Scala.AST.Value"
                        ]
                    ],
                    [
                        "BinOp",
                        [
                            "Morphir.Scala.AST.Value",
                            "String.String",
                            "Morphir.Scala.AST.Value"
                        ]
                    ],
                    [
                        "Lambda",
                        [
                            "List.List ( Morphir.Scala.AST.Name, Maybe.Maybe Morphir.Scala.AST.Type )",
                            "Morphir.Scala.AST.Value"
                        ]
                    ],
                    [
                        "Block",
                        [
                            "List.List Morphir.Scala.AST.MemberDecl",
                            "Morphir.Scala.AST.Value"
                        ]
                    ],
                    [
                        "MatchCases",
                        [
                            "List.List ( Morphir.Scala.AST.Pattern, Morphir.Scala.AST.Value )"
                        ]
                    ],
                    [
                        "Match",
                        [
                            "Morphir.Scala.AST.Value",
                            "Morphir.Scala.AST.Value"
                        ]
                    ],
                    [
                        "IfElse",
                        [
                            "Morphir.Scala.AST.Value",
                            "Morphir.Scala.AST.Value",
                            "Morphir.Scala.AST.Value"
                        ]
                    ],
                    [
                        "Tuple",
                        [
                            "List.List Morphir.Scala.AST.Value"
                        ]
                    ],
                    [
                        "StructuralValue",
                        [
                            "List.List ( Morphir.Scala.AST.Name, Morphir.Scala.AST.Value )"
                        ]
                    ],
                    [
                        "Unit",
                        []
                    ],
                    [
                        "This",
                        []
                    ],
                    [
                        "CommentedValue",
                        [
                            "Morphir.Scala.AST.Value",
                            "String.String"
                        ]
                    ],
                    [
                        "ForComp",
                        [
                            "List.List Morphir.Scala.AST.Generator",
                            "Morphir.Scala.AST.Value"
                        ]
                    ]
                ]
            }
        ],
        "aliases": [
            {
                "name": "Annotated",
                "comment": " ",
                "args": [
                    "a"
                ],
                "type": "{ annotations : List.List String.String, value : a }"
            },
            {
                "name": "ArgDecl",
                "comment": " ",
                "args": [],
                "type": "{ modifiers : List.List Morphir.Scala.AST.Mod, tpe : Morphir.Scala.AST.Type, name : Morphir.Scala.AST.Name, defaultValue : Maybe.Maybe Morphir.Scala.AST.Value }"
            },
            {
                "name": "CompilationUnit",
                "comment": " ",
                "args": [],
                "type": "{ dirPath : List.List String.String, fileName : String.String, packageDecl : Morphir.Scala.AST.PackageDecl, imports : List.List Morphir.Scala.AST.ImportDecl, typeDecls : List.List (Morphir.Scala.AST.Documented (Morphir.Scala.AST.Annotated Morphir.Scala.AST.TypeDecl)) }"
            },
            {
                "name": "Documented",
                "comment": " ",
                "args": [
                    "a"
                ],
                "type": "{ doc : Maybe.Maybe String.String, value : a }"
            },
            {
                "name": "ImportDecl",
                "comment": " ",
                "args": [],
                "type": "{ isAbsolute : Basics.Bool, packagePrefix : List.List String.String, importNames : List.List Morphir.Scala.AST.ImportName }"
            },
            {
                "name": "Name",
                "comment": " ",
                "args": [],
                "type": "String.String"
            },
            {
                "name": "PackageDecl",
                "comment": " ",
                "args": [],
                "type": "List.List String.String"
            },
            {
                "name": "Path",
                "comment": " ",
                "args": [],
                "type": "List.List Morphir.Scala.AST.Name"
            }
        ],
        "values": [
            {
                "name": "nameOfTypeDecl",
                "comment": " ",
                "type": "Morphir.Scala.AST.TypeDecl -> Morphir.Scala.AST.Name"
            },
            {
                "name": "withAnnotation",
                "comment": " Wrap in Annotated with an annotation value.\n",
                "type": "List.List String.String -> a -> Morphir.Scala.AST.Annotated a"
            },
            {
                "name": "withoutAnnotation",
                "comment": " Wrap in Annotated without any annotation values.\n",
                "type": "a -> Morphir.Scala.AST.Annotated a"
            }
        ],
        "binops": []
    },
    {
        "name": "Morphir.Scala.Backend",
        "comment": " This module encapsulates the Scala backend. It takes the Morphir IR as the input and returns an in-memory\nrepresentation of files generated. The consumer is responsible for getting the input IR and saving the output\nto the file-system.\n\n@docs mapDistribution, mapFunctionBody, mapType, mapTypeMember, mapValue, mapFQNameToTypeRef, mapFQNameToPathAndName, mapValueName\n\n\n# Options\n\n@docs Options\n\n",
        "unions": [],
        "aliases": [
            {
                "name": "Options",
                "comment": " Placeholder for code generator options. Currently empty.\n",
                "args": [],
                "type": "{ limitToModules : Maybe.Maybe (Set.Set Morphir.IR.Module.ModuleName) }"
            }
        ],
        "values": [
            {
                "name": "mapDistribution",
                "comment": " Entry point for the Scala backend. It takes the Morphir IR as the input and returns an in-memory\nrepresentation of files generated.\n",
                "type": "Morphir.Scala.Backend.Options -> Morphir.IR.Distribution.Distribution -> Morphir.File.FileMap.FileMap"
            },
            {
                "name": "mapFQNameToPathAndName",
                "comment": " Map a Morphir fully-qualified name to a Scala package path and name.\n",
                "type": "Morphir.IR.FQName.FQName -> ( Morphir.Scala.AST.Path, Morphir.IR.Name.Name )"
            },
            {
                "name": "mapFQNameToTypeRef",
                "comment": " Map Fully Qualified name Type Ref\n",
                "type": "Morphir.IR.FQName.FQName -> Morphir.Scala.AST.Type"
            },
            {
                "name": "mapFunctionBody",
                "comment": " Generate Scala for a Morphir function body.\n",
                "type": "Morphir.IR.Distribution.Distribution -> Morphir.IR.Value.Definition ta (Morphir.IR.Type.Type ()) -> Morphir.Scala.AST.Value"
            },
            {
                "name": "mapType",
                "comment": " Map a Morphir type to a Scala type.\n",
                "type": "Morphir.IR.Type.Type a -> Morphir.Scala.AST.Type"
            },
            {
                "name": "mapTypeMember",
                "comment": " Map a module level type declaration in Morphir to a Scala member declaration.\n",
                "type": "Morphir.IR.Package.PackageName -> Morphir.IR.Path.Path -> Morphir.IR.AccessControlled.AccessControlled (Morphir.IR.Module.Definition ta (Morphir.IR.Type.Type ())) -> ( Morphir.IR.Name.Name, Morphir.IR.AccessControlled.AccessControlled (Morphir.IR.Documented.Documented (Morphir.IR.Type.Definition ta)) ) -> List.List (Morphir.Scala.AST.Annotated Morphir.Scala.AST.MemberDecl)"
            },
            {
                "name": "mapValue",
                "comment": " Generate Scala for a value.\n",
                "type": "Set.Set Morphir.IR.Name.Name -> Morphir.IR.Value.Value ta (Morphir.IR.Type.Type ()) -> Morphir.Scala.AST.Value"
            },
            {
                "name": "mapValueName",
                "comment": " Map IR value to Scala Value\n",
                "type": "Morphir.IR.Name.Name -> String.String"
            }
        ],
        "binops": []
    },
    {
        "name": "Morphir.Scala.Backend.Codec",
        "comment": " Codecs for types in the `Morphir.Scala.Backend` module.\n\n\n# Options\n\n@docs decodeOptions\n\n",
        "unions": [],
        "aliases": [],
        "values": [
            {
                "name": "decodeOptions",
                "comment": " Decode Options.\n",
                "type": "Json.Decode.Decoder Morphir.Scala.Backend.Options"
            }
        ],
        "binops": []
    },
    {
        "name": "Morphir.Scala.PrettyPrinter",
        "comment": " Pretty-printer for the Scala AST.\n\n@docs Options, mapCompilationUnit, mapMemberDecl\n\n",
        "unions": [],
        "aliases": [
            {
                "name": "Options",
                "comment": " ",
                "args": [],
                "type": "{ indentDepth : Basics.Int, maxWidth : Basics.Int }"
            }
        ],
        "values": [
            {
                "name": "mapCompilationUnit",
                "comment": " ",
                "type": "Morphir.Scala.PrettyPrinter.Options -> Morphir.Scala.AST.CompilationUnit -> Morphir.File.SourceCode.Doc"
            },
            {
                "name": "mapMemberDecl",
                "comment": " Map a member declaration to Doc.\n",
                "type": "Morphir.Scala.PrettyPrinter.Options -> Morphir.Scala.AST.MemberDecl -> Morphir.File.SourceCode.Doc"
            }
        ],
        "binops": []
    },
    {
        "name": "Morphir.Type.Cardinality",
        "comment": " This module contains utilities to calculate the cardinality of types.\n\n@docs Cardinality, AlephNumber, cardinality\n\n",
        "unions": [
            {
                "name": "Cardinality",
                "comment": " Type cardinality represents the number of possible values for a given type.\n<https://en.wikipedia.org/wiki/Cardinality>\n",
                "args": [],
                "cases": []
            }
        ],
        "aliases": [
            {
                "name": "AlephNumber",
                "comment": " Represents an Aleph number that allows you to compare various levels of infinity\n<https://en.wikipedia.org/wiki/Aleph_number>\n",
                "args": [],
                "type": "Basics.Int"
            }
        ],
        "values": [
            {
                "name": "cardinality",
                "comment": " Calculate the cardinality of a type going down recursively in the type expression tree.\n",
                "type": "Morphir.IR.IR -> Dict.Dict Morphir.IR.Name.Name (Morphir.IR.Type.Type ()) -> Morphir.IR.Type.Type () -> Morphir.Type.Cardinality.Cardinality"
            }
        ],
        "binops": []
    },
    {
        "name": "Morphir.Value.Interpreter",
        "comment": " This module contains an interpreter for Morphir expressions. The interpreter takes a piece of logic as input,\nevaluates it and returns the resulting data. In Morphir both logic and data is captured as a `Value` so the interpreter\ntakes a `Value` and returns a `Value` (or an error for invalid expressions):\n\n@docs evaluate, evaluateValue, evaluateFunctionValue, matchPattern\n\n",
        "unions": [],
        "aliases": [],
        "values": [
            {
                "name": "evaluate",
                "comment": " Evaluates a value expression and returns another value expression or an error. You can also pass in other values\nby fully-qualified name that will be used for lookup if the expression contains references.\n\n    evaluate\n        SDK.nativeFunctions\n        (Value.Apply ()\n            (Value.Reference () (fqn \"Morphir.SDK\" \"Basics\" \"not\"))\n            (Value.Literal () (BoolLiteral True))\n        )\n        -- (Value.Literal () (BoolLiteral False))\n\n",
                "type": "Dict.Dict Morphir.IR.FQName.FQName Morphir.Value.Native.Function -> Morphir.IR.IR -> Morphir.IR.Value.RawValue -> Result.Result Morphir.Value.Error.Error Morphir.IR.Value.RawValue"
            },
            {
                "name": "evaluateFunctionValue",
                "comment": " ",
                "type": "Dict.Dict Morphir.IR.FQName.FQName Morphir.Value.Native.Function -> Morphir.IR.IR -> Morphir.IR.FQName.FQName -> List.List (Maybe.Maybe Morphir.IR.Value.RawValue) -> Result.Result Morphir.Value.Error.Error Morphir.IR.Value.RawValue"
            },
            {
                "name": "evaluateValue",
                "comment": " Evaluates a value expression recursively in a single pass while keeping track of variables and arguments along the\nevaluation.\n",
                "type": "Dict.Dict Morphir.IR.FQName.FQName Morphir.Value.Native.Function -> Morphir.IR.IR -> Morphir.Value.Interpreter.Variables -> List.List Morphir.IR.Value.RawValue -> Morphir.IR.Value.RawValue -> Result.Result Morphir.Value.Error.Error Morphir.IR.Value.RawValue"
            },
            {
                "name": "matchPattern",
                "comment": " Matches a value against a pattern recursively. It either returns an error if there is a mismatch or a dictionary of\nvariable names to values extracted out of the pattern.\n",
                "type": "Morphir.IR.Value.Pattern () -> Morphir.IR.Value.RawValue -> Result.Result Morphir.Value.Error.PatternMismatch Morphir.Value.Interpreter.Variables"
            }
        ],
        "binops": []
    },
    {
        "name": "Morphir.Value.Native",
        "comment": " This module contains an API and some tools to implement native functions. Native functions are functions that are\nnot expressed in terms Morphir expressions either because they cannot be or they are more efficient natively. Native in\nthis context means evaluating within Elm which in turn translates to JavaScript which either executes in the browser or\non the backend using Node.\n\nNative functions are mainly used in the interpreter for evaluating SDK functions. Think of simple things like adding two\nnumbers: the IR captures the fact that you want to add them in a reference `Morphir.SDK.Basics.add` and the interpreter\nfinds the native function that actually adds the two numbers (which would be impossible to express in Morphir since it's\na primitive operation).\n\n@docs Function\n\n\n## Lazy evaluation\n\nOne important thing to understand is that the API allows lazy evaluation. Instead of evaluating arguments before they\nare passed to the native function they are passed without evaluation. This allows the native function itself to decide\nwhat order to evaluate arguments in. Think of the boolean `and` and `or` operators, they can often skip evaluation of\nthe second argument depending on the value of the first argument.\n\nAlso, when a lambda is passed as an argument it might need to be evaluated multiple times with different inputs. For\nexample the predicate in a `filter` will need to be evaluated on each item in the list.\n\n@docs Eval\n\n\n# Utilities\n\nVarious utilities to help with implementing native functions.\n\n@docs unaryLazy, unaryStrict, binaryLazy, binaryStrict, boolLiteral, charLiteral, eval0, eval1, eval2, eval3\n@docs floatLiteral, intLiteral, oneOf, stringLiteral, decimalLiteral\n@docs decodeFun1, decodeList, decodeLiteral, decodeMaybe, decodeRaw, decodeTuple2, encodeList, encodeLiteral, encodeMaybe, encodeMaybeResult, encodeRaw, encodeResultList, encodeTuple2\n@docs trinaryLazy, trinaryStrict\n\n",
        "unions": [],
        "aliases": [
            {
                "name": "Eval",
                "comment": " Type that captures a function used for evaluation. This will usually backed by the interpreter.\n",
                "args": [],
                "type": "Morphir.IR.Value.RawValue -> Result.Result Morphir.Value.Error.Error Morphir.IR.Value.RawValue"
            },
            {
                "name": "Function",
                "comment": " Type that represents a native function. It's a function that takes two arguments:\n\n  - A function to evaluate values. See the section on [Lazy evaluation](#Lazy_evaluation) for details.\n  - The list of arguments.\n\n",
                "args": [],
                "type": "Morphir.Value.Native.Eval -> List.List Morphir.IR.Value.RawValue -> Result.Result Morphir.Value.Error.Error Morphir.IR.Value.RawValue"
            }
        ],
        "values": [
            {
                "name": "binaryLazy",
                "comment": " Create a native function that takes exactly two arguments. Let the implementor decide when to evaluate the arguments.\n\n    nativeFunction : Native.Function\n    nativeFunction =\n        binaryLazy\n            (\\eval arg1 arg2 ->\n                eval arg1\n                    |> Result.andThen\n                        (\\evaluatedArg1 ->\n                            eval arg2\n                                |> Result.andThen\n                                    (\\evaluatedArg2 ->\n                                        -- do something with evaluatedArg1 and evaluatedArg2\n                                    )\n                        )\n            )\n\n",
                "type": "(Morphir.Value.Native.Eval -> Morphir.IR.Value.RawValue -> Morphir.IR.Value.RawValue -> Result.Result Morphir.Value.Error.Error Morphir.IR.Value.RawValue) -> Morphir.Value.Native.Function"
            },
            {
                "name": "binaryStrict",
                "comment": " Create a native function that takes exactly two arguments. Evaluate both arguments before passing then to the supplied\nfunction.\n\n    nativeFunction : Native.Function\n    nativeFunction =\n        binaryStrict\n            (\\eval evaluatedArg1 evaluatedArg2 ->\n                -- do something with evaluatedArg1 and evaluatedArg2\n            )\n\n",
                "type": "(Morphir.IR.Value.RawValue -> Morphir.IR.Value.RawValue -> Result.Result Morphir.Value.Error.Error Morphir.IR.Value.RawValue) -> Morphir.Value.Native.Function"
            },
            {
                "name": "boolLiteral",
                "comment": " ",
                "type": "Morphir.IR.Literal.Literal -> Result.Result Morphir.Value.Error.Error Basics.Bool"
            },
            {
                "name": "charLiteral",
                "comment": " ",
                "type": "Morphir.IR.Literal.Literal -> Result.Result Morphir.Value.Error.Error Char.Char"
            },
            {
                "name": "decimalLiteral",
                "comment": " ",
                "type": "Morphir.IR.Literal.Literal -> Result.Result Morphir.Value.Error.Error Morphir.SDK.Decimal.Decimal"
            },
            {
                "name": "decodeFun1",
                "comment": " ",
                "type": "Morphir.Value.Native.Encode a -> Morphir.Value.Native.Decoder r -> Morphir.Value.Native.Eval -> Morphir.IR.Value.RawValue -> Result.Result Morphir.Value.Error.Error (a -> Result.Result Morphir.Value.Error.Error r)"
            },
            {
                "name": "decodeList",
                "comment": " ",
                "type": "Morphir.Value.Native.Decoder a -> Morphir.Value.Native.Eval -> Morphir.IR.Value.RawValue -> Result.Result Morphir.Value.Error.Error (List.List a)"
            },
            {
                "name": "decodeLiteral",
                "comment": " ",
                "type": "(Morphir.IR.Literal.Literal -> Result.Result Morphir.Value.Error.Error a) -> Morphir.Value.Native.Eval -> Morphir.IR.Value.RawValue -> Result.Result Morphir.Value.Error.Error a"
            },
            {
                "name": "decodeMaybe",
                "comment": " ",
                "type": "Morphir.Value.Native.Decoder a -> Morphir.Value.Native.Eval -> Morphir.IR.Value.RawValue -> Result.Result Morphir.Value.Error.Error (Maybe.Maybe a)"
            },
            {
                "name": "decodeRaw",
                "comment": " ",
                "type": "Morphir.Value.Native.Eval -> Morphir.IR.Value.RawValue -> Result.Result Morphir.Value.Error.Error Morphir.IR.Value.RawValue"
            },
            {
                "name": "decodeTuple2",
                "comment": " ",
                "type": "( Morphir.Value.Native.Decoder a, Morphir.Value.Native.Decoder b ) -> Morphir.Value.Native.Eval -> Morphir.IR.Value.RawValue -> Result.Result Morphir.Value.Error.Error ( a, b )"
            },
            {
                "name": "encodeList",
                "comment": " ",
                "type": "Morphir.Value.Native.Encode a -> List.List a -> Result.Result Morphir.Value.Error.Error Morphir.IR.Value.RawValue"
            },
            {
                "name": "encodeLiteral",
                "comment": " ",
                "type": "(a -> Morphir.IR.Literal.Literal) -> a -> Result.Result Morphir.Value.Error.Error Morphir.IR.Value.RawValue"
            },
            {
                "name": "encodeMaybe",
                "comment": " ",
                "type": "Morphir.Value.Native.Encode a -> Maybe.Maybe a -> Result.Result Morphir.Value.Error.Error Morphir.IR.Value.RawValue"
            },
            {
                "name": "encodeMaybeResult",
                "comment": " ",
                "type": "Maybe.Maybe (Result.Result Morphir.Value.Error.Error Morphir.IR.Value.RawValue) -> Result.Result Morphir.Value.Error.Error Morphir.IR.Value.RawValue"
            },
            {
                "name": "encodeRaw",
                "comment": " ",
                "type": "Morphir.IR.Value.RawValue -> Result.Result Morphir.Value.Error.Error Morphir.IR.Value.RawValue"
            },
            {
                "name": "encodeResultList",
                "comment": " ",
                "type": "List.List (Result.Result Morphir.Value.Error.Error Morphir.IR.Value.RawValue) -> Result.Result Morphir.Value.Error.Error Morphir.IR.Value.RawValue"
            },
            {
                "name": "encodeTuple2",
                "comment": " ",
                "type": "( Morphir.Value.Native.Encode a, Morphir.Value.Native.Encode b ) -> ( a, b ) -> Result.Result Morphir.Value.Error.Error Morphir.IR.Value.RawValue"
            },
            {
                "name": "eval0",
                "comment": " ",
                "type": "r -> Morphir.Value.Native.Encode r -> Morphir.Value.Native.Function"
            },
            {
                "name": "eval1",
                "comment": " ",
                "type": "(a -> r) -> Morphir.Value.Native.Decoder a -> Morphir.Value.Native.Encode r -> Morphir.Value.Native.Eval -> List.List Morphir.IR.Value.RawValue -> Result.Result Morphir.Value.Error.Error Morphir.IR.Value.RawValue"
            },
            {
                "name": "eval2",
                "comment": " ",
                "type": "(a -> b -> r) -> Morphir.Value.Native.Decoder a -> Morphir.Value.Native.Decoder b -> Morphir.Value.Native.Encode r -> Morphir.Value.Native.Eval -> List.List Morphir.IR.Value.RawValue -> Result.Result Morphir.Value.Error.Error Morphir.IR.Value.RawValue"
            },
            {
                "name": "eval3",
                "comment": " ",
                "type": "(a -> b -> c -> r) -> Morphir.Value.Native.Decoder a -> Morphir.Value.Native.Decoder b -> Morphir.Value.Native.Decoder c -> Morphir.Value.Native.Encode r -> Morphir.Value.Native.Eval -> List.List Morphir.IR.Value.RawValue -> Result.Result Morphir.Value.Error.Error Morphir.IR.Value.RawValue"
            },
            {
                "name": "floatLiteral",
                "comment": " ",
                "type": "Morphir.IR.Literal.Literal -> Result.Result Morphir.Value.Error.Error Basics.Float"
            },
            {
                "name": "intLiteral",
                "comment": " ",
                "type": "Morphir.IR.Literal.Literal -> Result.Result Morphir.Value.Error.Error Basics.Int"
            },
            {
                "name": "oneOf",
                "comment": " ",
                "type": "List.List Morphir.Value.Native.Function -> Morphir.Value.Native.Function"
            },
            {
                "name": "stringLiteral",
                "comment": " ",
                "type": "Morphir.IR.Literal.Literal -> Result.Result Morphir.Value.Error.Error String.String"
            },
            {
                "name": "trinaryLazy",
                "comment": " ",
                "type": "(Morphir.Value.Native.Eval -> Morphir.IR.Value.RawValue -> Morphir.IR.Value.RawValue -> Morphir.IR.Value.RawValue -> Result.Result Morphir.Value.Error.Error Morphir.IR.Value.RawValue) -> Morphir.Value.Native.Function"
            },
            {
                "name": "trinaryStrict",
                "comment": " ",
                "type": "(Morphir.IR.Value.RawValue -> Morphir.IR.Value.RawValue -> Morphir.IR.Value.RawValue -> Result.Result Morphir.Value.Error.Error Morphir.IR.Value.RawValue) -> Morphir.Value.Native.Function"
            },
            {
                "name": "unaryLazy",
                "comment": " Create a native function that takes exactly one argument. Let the implementor decide when to evaluate the argument.\n\n    nativeFunction : Native.Function\n    nativeFunction =\n        unaryLazy\n            (\\eval arg ->\n                eval arg\n                    |> Result.map\n                        (\\evaluatedArg ->\n                            -- do something\n                        )\n            )\n\n",
                "type": "(Morphir.Value.Native.Eval -> Morphir.IR.Value.RawValue -> Result.Result Morphir.Value.Error.Error Morphir.IR.Value.RawValue) -> Morphir.Value.Native.Function"
            },
            {
                "name": "unaryStrict",
                "comment": " Create a native function that takes exactly one argument. Evaluate the argument before passing it to the supplied\nfunction.\n\n    nativeFunction : Native.Function\n    nativeFunction =\n        unaryLazy\n            (\\eval evaluatedArg ->\n                -- do something with evaluatedArg\n            )\n\n",
                "type": "(Morphir.Value.Native.Eval -> Morphir.IR.Value.RawValue -> Result.Result Morphir.Value.Error.Error Morphir.IR.Value.RawValue) -> Morphir.Value.Native.Function"
            }
        ],
        "binops": []
    }
]